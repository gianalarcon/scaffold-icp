/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/borc";
exports.ids = ["vendor-chunks/borc"];
exports.modules = {

/***/ "(ssr)/../../node_modules/borc/src/constants.js":
/*!************************************************!*\
  !*** ../../node_modules/borc/src/constants.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Bignumber = (__webpack_require__(/*! bignumber.js */ \"(ssr)/../../node_modules/bignumber.js/bignumber.js\").BigNumber)\n\nexports.MT = {\n  POS_INT: 0,\n  NEG_INT: 1,\n  BYTE_STRING: 2,\n  UTF8_STRING: 3,\n  ARRAY: 4,\n  MAP: 5,\n  TAG: 6,\n  SIMPLE_FLOAT: 7\n}\n\nexports.TAG = {\n  DATE_STRING: 0,\n  DATE_EPOCH: 1,\n  POS_BIGINT: 2,\n  NEG_BIGINT: 3,\n  DECIMAL_FRAC: 4,\n  BIGFLOAT: 5,\n  BASE64URL_EXPECTED: 21,\n  BASE64_EXPECTED: 22,\n  BASE16_EXPECTED: 23,\n  CBOR: 24,\n  URI: 32,\n  BASE64URL: 33,\n  BASE64: 34,\n  REGEXP: 35,\n  MIME: 36\n}\n\nexports.NUMBYTES = {\n  ZERO: 0,\n  ONE: 24,\n  TWO: 25,\n  FOUR: 26,\n  EIGHT: 27,\n  INDEFINITE: 31\n}\n\nexports.SIMPLE = {\n  FALSE: 20,\n  TRUE: 21,\n  NULL: 22,\n  UNDEFINED: 23\n}\n\nexports.SYMS = {\n  NULL: Symbol('null'),\n  UNDEFINED: Symbol('undef'),\n  PARENT: Symbol('parent'),\n  BREAK: Symbol('break'),\n  STREAM: Symbol('stream')\n}\n\nexports.SHIFT32 = Math.pow(2, 32)\nexports.SHIFT16 = Math.pow(2, 16)\n\nexports.MAX_SAFE_HIGH = 0x1fffff\nexports.NEG_ONE = new Bignumber(-1)\nexports.TEN = new Bignumber(10)\nexports.TWO = new Bignumber(2)\n\nexports.PARENT = {\n  ARRAY: 0,\n  OBJECT: 1,\n  MAP: 2,\n  TAG: 3,\n  BYTE_STRING: 4,\n  UTF8_STRING: 5\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixrQkFBa0IseUdBQWlDOztBQUVuRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2YsZUFBZTs7QUFFZixxQkFBcUI7QUFDckIsZUFBZTtBQUNmLFdBQVc7QUFDWCxXQUFXOztBQUVYLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL25vYm9keTEvV29yay9xM3gvc2NhZmZvbGQtaWNwL25vZGVfbW9kdWxlcy9ib3JjL3NyYy9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEJpZ251bWJlciA9IHJlcXVpcmUoJ2JpZ251bWJlci5qcycpLkJpZ051bWJlclxuXG5leHBvcnRzLk1UID0ge1xuICBQT1NfSU5UOiAwLFxuICBORUdfSU5UOiAxLFxuICBCWVRFX1NUUklORzogMixcbiAgVVRGOF9TVFJJTkc6IDMsXG4gIEFSUkFZOiA0LFxuICBNQVA6IDUsXG4gIFRBRzogNixcbiAgU0lNUExFX0ZMT0FUOiA3XG59XG5cbmV4cG9ydHMuVEFHID0ge1xuICBEQVRFX1NUUklORzogMCxcbiAgREFURV9FUE9DSDogMSxcbiAgUE9TX0JJR0lOVDogMixcbiAgTkVHX0JJR0lOVDogMyxcbiAgREVDSU1BTF9GUkFDOiA0LFxuICBCSUdGTE9BVDogNSxcbiAgQkFTRTY0VVJMX0VYUEVDVEVEOiAyMSxcbiAgQkFTRTY0X0VYUEVDVEVEOiAyMixcbiAgQkFTRTE2X0VYUEVDVEVEOiAyMyxcbiAgQ0JPUjogMjQsXG4gIFVSSTogMzIsXG4gIEJBU0U2NFVSTDogMzMsXG4gIEJBU0U2NDogMzQsXG4gIFJFR0VYUDogMzUsXG4gIE1JTUU6IDM2XG59XG5cbmV4cG9ydHMuTlVNQllURVMgPSB7XG4gIFpFUk86IDAsXG4gIE9ORTogMjQsXG4gIFRXTzogMjUsXG4gIEZPVVI6IDI2LFxuICBFSUdIVDogMjcsXG4gIElOREVGSU5JVEU6IDMxXG59XG5cbmV4cG9ydHMuU0lNUExFID0ge1xuICBGQUxTRTogMjAsXG4gIFRSVUU6IDIxLFxuICBOVUxMOiAyMixcbiAgVU5ERUZJTkVEOiAyM1xufVxuXG5leHBvcnRzLlNZTVMgPSB7XG4gIE5VTEw6IFN5bWJvbCgnbnVsbCcpLFxuICBVTkRFRklORUQ6IFN5bWJvbCgndW5kZWYnKSxcbiAgUEFSRU5UOiBTeW1ib2woJ3BhcmVudCcpLFxuICBCUkVBSzogU3ltYm9sKCdicmVhaycpLFxuICBTVFJFQU06IFN5bWJvbCgnc3RyZWFtJylcbn1cblxuZXhwb3J0cy5TSElGVDMyID0gTWF0aC5wb3coMiwgMzIpXG5leHBvcnRzLlNISUZUMTYgPSBNYXRoLnBvdygyLCAxNilcblxuZXhwb3J0cy5NQVhfU0FGRV9ISUdIID0gMHgxZmZmZmZcbmV4cG9ydHMuTkVHX09ORSA9IG5ldyBCaWdudW1iZXIoLTEpXG5leHBvcnRzLlRFTiA9IG5ldyBCaWdudW1iZXIoMTApXG5leHBvcnRzLlRXTyA9IG5ldyBCaWdudW1iZXIoMilcblxuZXhwb3J0cy5QQVJFTlQgPSB7XG4gIEFSUkFZOiAwLFxuICBPQkpFQ1Q6IDEsXG4gIE1BUDogMixcbiAgVEFHOiAzLFxuICBCWVRFX1NUUklORzogNCxcbiAgVVRGOF9TVFJJTkc6IDVcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/borc/src/constants.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/borc/src/decoder.asm.js":
/*!**************************************************!*\
  !*** ../../node_modules/borc/src/decoder.asm.js ***!
  \**************************************************/
/***/ ((module) => {

eval("/* eslint-disable */\n\nmodule.exports = function decodeAsm (stdlib, foreign, buffer) {\n  'use asm'\n\n  // -- Imports\n\n  var heap = new stdlib.Uint8Array(buffer)\n  // var log = foreign.log\n  var pushInt = foreign.pushInt\n  var pushInt32 = foreign.pushInt32\n  var pushInt32Neg = foreign.pushInt32Neg\n  var pushInt64 = foreign.pushInt64\n  var pushInt64Neg = foreign.pushInt64Neg\n  var pushFloat = foreign.pushFloat\n  var pushFloatSingle = foreign.pushFloatSingle\n  var pushFloatDouble = foreign.pushFloatDouble\n  var pushTrue = foreign.pushTrue\n  var pushFalse = foreign.pushFalse\n  var pushUndefined = foreign.pushUndefined\n  var pushNull = foreign.pushNull\n  var pushInfinity = foreign.pushInfinity\n  var pushInfinityNeg = foreign.pushInfinityNeg\n  var pushNaN = foreign.pushNaN\n  var pushNaNNeg = foreign.pushNaNNeg\n\n  var pushArrayStart = foreign.pushArrayStart\n  var pushArrayStartFixed = foreign.pushArrayStartFixed\n  var pushArrayStartFixed32 = foreign.pushArrayStartFixed32\n  var pushArrayStartFixed64 = foreign.pushArrayStartFixed64\n  var pushObjectStart = foreign.pushObjectStart\n  var pushObjectStartFixed = foreign.pushObjectStartFixed\n  var pushObjectStartFixed32 = foreign.pushObjectStartFixed32\n  var pushObjectStartFixed64 = foreign.pushObjectStartFixed64\n\n  var pushByteString = foreign.pushByteString\n  var pushByteStringStart = foreign.pushByteStringStart\n  var pushUtf8String = foreign.pushUtf8String\n  var pushUtf8StringStart = foreign.pushUtf8StringStart\n\n  var pushSimpleUnassigned = foreign.pushSimpleUnassigned\n\n  var pushTagStart = foreign.pushTagStart\n  var pushTagStart4 = foreign.pushTagStart4\n  var pushTagStart8 = foreign.pushTagStart8\n  var pushTagUnassigned = foreign.pushTagUnassigned\n\n  var pushBreak = foreign.pushBreak\n\n  var pow = stdlib.Math.pow\n\n  // -- Constants\n\n\n  // -- Mutable Variables\n\n  var offset = 0\n  var inputLength = 0\n  var code = 0\n\n  // Decode a cbor string represented as Uint8Array\n  // which is allocated on the heap from 0 to inputLength\n  //\n  // input - Int\n  //\n  // Returns Code - Int,\n  // Success = 0\n  // Error > 0\n  function parse (input) {\n    input = input | 0\n\n    offset = 0\n    inputLength = input\n\n    while ((offset | 0) < (inputLength | 0)) {\n      code = jumpTable[heap[offset] & 255](heap[offset] | 0) | 0\n\n      if ((code | 0) > 0) {\n        break\n      }\n    }\n\n    return code | 0\n  }\n\n  // -- Helper Function\n\n  function checkOffset (n) {\n    n = n | 0\n\n    if ((((offset | 0) + (n | 0)) | 0) < (inputLength | 0)) {\n      return 0\n    }\n\n    return 1\n  }\n\n  function readUInt16 (n) {\n    n = n | 0\n\n    return (\n      (heap[n | 0] << 8) | heap[(n + 1) | 0]\n    ) | 0\n  }\n\n  function readUInt32 (n) {\n    n = n | 0\n\n    return (\n      (heap[n | 0] << 24) | (heap[(n + 1) | 0] << 16) | (heap[(n + 2) | 0] << 8) | heap[(n + 3) | 0]\n    ) | 0\n  }\n\n  // -- Initial Byte Handlers\n\n  function INT_P (octet) {\n    octet = octet | 0\n\n    pushInt(octet | 0)\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function UINT_P_8 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushInt(heap[(offset + 1) | 0] | 0)\n\n    offset = (offset + 2) | 0\n\n    return 0\n  }\n\n  function UINT_P_16 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    pushInt(\n      readUInt16((offset + 1) | 0) | 0\n    )\n\n    offset = (offset + 3) | 0\n\n    return 0\n  }\n\n  function UINT_P_32 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushInt32(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0\n    )\n\n    offset = (offset + 5) | 0\n\n    return 0\n  }\n\n  function UINT_P_64 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushInt64(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0,\n      readUInt16((offset + 5) | 0) | 0,\n      readUInt16((offset + 7) | 0) | 0\n    )\n\n    offset = (offset + 9) | 0\n\n    return 0\n  }\n\n  function INT_N (octet) {\n    octet = octet | 0\n\n    pushInt((-1 - ((octet - 32) | 0)) | 0)\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function UINT_N_8 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushInt(\n      (-1 - (heap[(offset + 1) | 0] | 0)) | 0\n    )\n\n    offset = (offset + 2) | 0\n\n    return 0\n  }\n\n  function UINT_N_16 (octet) {\n    octet = octet | 0\n\n    var val = 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    val = readUInt16((offset + 1) | 0) | 0\n    pushInt((-1 - (val | 0)) | 0)\n\n    offset = (offset + 3) | 0\n\n    return 0\n  }\n\n  function UINT_N_32 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushInt32Neg(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0\n    )\n\n    offset = (offset + 5) | 0\n\n    return 0\n  }\n\n  function UINT_N_64 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushInt64Neg(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0,\n      readUInt16((offset + 5) | 0) | 0,\n      readUInt16((offset + 7) | 0) | 0\n    )\n\n    offset = (offset + 9) | 0\n\n    return 0\n  }\n\n  function BYTE_STRING (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var step = 0\n\n    step = (octet - 64) | 0\n    if (checkOffset(step | 0) | 0) {\n      return 1\n    }\n\n    start = (offset + 1) | 0\n    end = (((offset + 1) | 0) + (step | 0)) | 0\n\n    pushByteString(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function BYTE_STRING_8 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    length = heap[(offset + 1) | 0] | 0\n    start = (offset + 2) | 0\n    end = (((offset + 2) | 0) + (length | 0)) | 0\n\n    if (checkOffset((length + 1) | 0) | 0) {\n      return 1\n    }\n\n    pushByteString(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function BYTE_STRING_16 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    length = readUInt16((offset + 1) | 0) | 0\n    start = (offset + 3) | 0\n    end = (((offset + 3) | 0) + (length | 0)) | 0\n\n\n    if (checkOffset((length + 2) | 0) | 0) {\n      return 1\n    }\n\n    pushByteString(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function BYTE_STRING_32 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    length = readUInt32((offset + 1) | 0) | 0\n    start = (offset + 5) | 0\n    end = (((offset + 5) | 0) + (length | 0)) | 0\n\n\n    if (checkOffset((length + 4) | 0) | 0) {\n      return 1\n    }\n\n    pushByteString(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function BYTE_STRING_64 (octet) {\n    // NOT IMPLEMENTED\n    octet = octet | 0\n\n    return 1\n  }\n\n  function BYTE_STRING_BREAK (octet) {\n    octet = octet | 0\n\n    pushByteStringStart()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function UTF8_STRING (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var step = 0\n\n    step = (octet - 96) | 0\n\n    if (checkOffset(step | 0) | 0) {\n      return 1\n    }\n\n    start = (offset + 1) | 0\n    end = (((offset + 1) | 0) + (step | 0)) | 0\n\n    pushUtf8String(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function UTF8_STRING_8 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    length = heap[(offset + 1) | 0] | 0\n    start = (offset + 2) | 0\n    end = (((offset + 2) | 0) + (length | 0)) | 0\n\n    if (checkOffset((length + 1) | 0) | 0) {\n      return 1\n    }\n\n    pushUtf8String(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function UTF8_STRING_16 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    length = readUInt16((offset + 1) | 0) | 0\n    start = (offset + 3) | 0\n    end = (((offset + 3) | 0) + (length | 0)) | 0\n\n    if (checkOffset((length + 2) | 0) | 0) {\n      return 1\n    }\n\n    pushUtf8String(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function UTF8_STRING_32 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    length = readUInt32((offset + 1) | 0) | 0\n    start = (offset + 5) | 0\n    end = (((offset + 5) | 0) + (length | 0)) | 0\n\n    if (checkOffset((length + 4) | 0) | 0) {\n      return 1\n    }\n\n    pushUtf8String(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function UTF8_STRING_64 (octet) {\n    // NOT IMPLEMENTED\n    octet = octet | 0\n\n    return 1\n  }\n\n  function UTF8_STRING_BREAK (octet) {\n    octet = octet | 0\n\n    pushUtf8StringStart()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function ARRAY (octet) {\n    octet = octet | 0\n\n    pushArrayStartFixed((octet - 128) | 0)\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function ARRAY_8 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushArrayStartFixed(heap[(offset + 1) | 0] | 0)\n\n    offset = (offset + 2) | 0\n\n    return 0\n  }\n\n  function ARRAY_16 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    pushArrayStartFixed(\n      readUInt16((offset + 1) | 0) | 0\n    )\n\n    offset = (offset + 3) | 0\n\n    return 0\n  }\n\n  function ARRAY_32 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushArrayStartFixed32(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0\n    )\n\n    offset = (offset + 5) | 0\n\n    return 0\n  }\n\n  function ARRAY_64 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushArrayStartFixed64(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0,\n      readUInt16((offset + 5) | 0) | 0,\n      readUInt16((offset + 7) | 0) | 0\n    )\n\n    offset = (offset + 9) | 0\n\n    return 0\n  }\n\n  function ARRAY_BREAK (octet) {\n    octet = octet | 0\n\n    pushArrayStart()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function MAP (octet) {\n    octet = octet | 0\n\n    var step = 0\n\n    step = (octet - 160) | 0\n\n    if (checkOffset(step | 0) | 0) {\n      return 1\n    }\n\n    pushObjectStartFixed(step | 0)\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function MAP_8 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushObjectStartFixed(heap[(offset + 1) | 0] | 0)\n\n    offset = (offset + 2) | 0\n\n    return 0\n  }\n\n  function MAP_16 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    pushObjectStartFixed(\n      readUInt16((offset + 1) | 0) | 0\n    )\n\n    offset = (offset + 3) | 0\n\n    return 0\n  }\n\n  function MAP_32 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushObjectStartFixed32(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0\n    )\n\n    offset = (offset + 5) | 0\n\n    return 0\n  }\n\n  function MAP_64 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushObjectStartFixed64(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0,\n      readUInt16((offset + 5) | 0) | 0,\n      readUInt16((offset + 7) | 0) | 0\n    )\n\n    offset = (offset + 9) | 0\n\n    return 0\n  }\n\n  function MAP_BREAK (octet) {\n    octet = octet | 0\n\n    pushObjectStart()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function TAG_KNOWN (octet) {\n    octet = octet | 0\n\n    pushTagStart((octet - 192| 0) | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BIGNUM_POS (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BIGNUM_NEG (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_FRAC (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BIGNUM_FLOAT (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_UNASSIGNED (octet) {\n    octet = octet | 0\n\n    pushTagStart((octet - 192| 0) | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BASE64_URL (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BASE64 (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BASE16 (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_MORE_1 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushTagStart(heap[(offset + 1) | 0] | 0)\n\n    offset = (offset + 2 | 0)\n\n    return 0\n  }\n\n  function TAG_MORE_2 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    pushTagStart(\n      readUInt16((offset + 1) | 0) | 0\n    )\n\n    offset = (offset + 3 | 0)\n\n    return 0\n  }\n\n  function TAG_MORE_4 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushTagStart4(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0\n    )\n\n    offset = (offset + 5 | 0)\n\n    return 0\n  }\n\n  function TAG_MORE_8 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushTagStart8(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0,\n      readUInt16((offset + 5) | 0) | 0,\n      readUInt16((offset + 7) | 0) | 0\n    )\n\n    offset = (offset + 9 | 0)\n\n    return 0\n  }\n\n  function SIMPLE_UNASSIGNED (octet) {\n    octet = octet | 0\n\n    pushSimpleUnassigned(((octet | 0) - 224) | 0)\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function SIMPLE_FALSE (octet) {\n    octet = octet | 0\n\n    pushFalse()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function SIMPLE_TRUE (octet) {\n    octet = octet | 0\n\n    pushTrue()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function SIMPLE_NULL (octet) {\n    octet = octet | 0\n\n    pushNull()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function SIMPLE_UNDEFINED (octet) {\n    octet = octet | 0\n\n    pushUndefined()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function SIMPLE_BYTE (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushSimpleUnassigned(heap[(offset + 1) | 0] | 0)\n\n    offset = (offset + 2)  | 0\n\n    return 0\n  }\n\n  function SIMPLE_FLOAT_HALF (octet) {\n    octet = octet | 0\n\n    var f = 0\n    var g = 0\n    var sign = 1.0\n    var exp = 0.0\n    var mant = 0.0\n    var r = 0.0\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    f = heap[(offset + 1) | 0] | 0\n    g = heap[(offset + 2) | 0] | 0\n\n    if ((f | 0) & 0x80) {\n      sign = -1.0\n    }\n\n    exp = +(((f | 0) & 0x7C) >> 2)\n    mant = +((((f | 0) & 0x03) << 8) | g)\n\n    if (+exp == 0.0) {\n      pushFloat(+(\n        (+sign) * +5.9604644775390625e-8 * (+mant)\n      ))\n    } else if (+exp == 31.0) {\n      if (+sign == 1.0) {\n        if (+mant > 0.0) {\n          pushNaN()\n        } else {\n          pushInfinity()\n        }\n      } else {\n        if (+mant > 0.0) {\n          pushNaNNeg()\n        } else {\n          pushInfinityNeg()\n        }\n      }\n    } else {\n      pushFloat(+(\n        +sign * pow(+2, +(+exp - 25.0)) * +(1024.0 + mant)\n      ))\n    }\n\n    offset = (offset + 3) | 0\n\n    return 0\n  }\n\n  function SIMPLE_FLOAT_SINGLE (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushFloatSingle(\n      heap[(offset + 1) | 0] | 0,\n      heap[(offset + 2) | 0] | 0,\n      heap[(offset + 3) | 0] | 0,\n      heap[(offset + 4) | 0] | 0\n    )\n\n    offset = (offset + 5) | 0\n\n    return 0\n  }\n\n  function SIMPLE_FLOAT_DOUBLE (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushFloatDouble(\n      heap[(offset + 1) | 0] | 0,\n      heap[(offset + 2) | 0] | 0,\n      heap[(offset + 3) | 0] | 0,\n      heap[(offset + 4) | 0] | 0,\n      heap[(offset + 5) | 0] | 0,\n      heap[(offset + 6) | 0] | 0,\n      heap[(offset + 7) | 0] | 0,\n      heap[(offset + 8) | 0] | 0\n    )\n\n    offset = (offset + 9) | 0\n\n    return 0\n  }\n\n  function ERROR (octet) {\n    octet = octet | 0\n\n    return 1\n  }\n\n  function BREAK (octet) {\n    octet = octet | 0\n\n    pushBreak()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  // -- Jump Table\n\n  var jumpTable = [\n    // Integer 0x00..0x17 (0..23)\n    INT_P, // 0x00\n    INT_P, // 0x01\n    INT_P, // 0x02\n    INT_P, // 0x03\n    INT_P, // 0x04\n    INT_P, // 0x05\n    INT_P, // 0x06\n    INT_P, // 0x07\n    INT_P, // 0x08\n    INT_P, // 0x09\n    INT_P, // 0x0A\n    INT_P, // 0x0B\n    INT_P, // 0x0C\n    INT_P, // 0x0D\n    INT_P, // 0x0E\n    INT_P, // 0x0F\n    INT_P, // 0x10\n    INT_P, // 0x11\n    INT_P, // 0x12\n    INT_P, // 0x13\n    INT_P, // 0x14\n    INT_P, // 0x15\n    INT_P, // 0x16\n    INT_P, // 0x17\n    // Unsigned integer (one-byte uint8_t follows)\n    UINT_P_8, // 0x18\n    // Unsigned integer (two-byte uint16_t follows)\n    UINT_P_16, // 0x19\n    // Unsigned integer (four-byte uint32_t follows)\n    UINT_P_32, // 0x1a\n    // Unsigned integer (eight-byte uint64_t follows)\n    UINT_P_64, // 0x1b\n    ERROR, // 0x1c\n    ERROR, // 0x1d\n    ERROR, // 0x1e\n    ERROR, // 0x1f\n    // Negative integer -1-0x00..-1-0x17 (-1..-24)\n    INT_N, // 0x20\n    INT_N, // 0x21\n    INT_N, // 0x22\n    INT_N, // 0x23\n    INT_N, // 0x24\n    INT_N, // 0x25\n    INT_N, // 0x26\n    INT_N, // 0x27\n    INT_N, // 0x28\n    INT_N, // 0x29\n    INT_N, // 0x2A\n    INT_N, // 0x2B\n    INT_N, // 0x2C\n    INT_N, // 0x2D\n    INT_N, // 0x2E\n    INT_N, // 0x2F\n    INT_N, // 0x30\n    INT_N, // 0x31\n    INT_N, // 0x32\n    INT_N, // 0x33\n    INT_N, // 0x34\n    INT_N, // 0x35\n    INT_N, // 0x36\n    INT_N, // 0x37\n    // Negative integer -1-n (one-byte uint8_t for n follows)\n    UINT_N_8, // 0x38\n    // Negative integer -1-n (two-byte uint16_t for n follows)\n    UINT_N_16, // 0x39\n    // Negative integer -1-n (four-byte uint32_t for nfollows)\n    UINT_N_32, // 0x3a\n    // Negative integer -1-n (eight-byte uint64_t for n follows)\n    UINT_N_64, // 0x3b\n    ERROR, // 0x3c\n    ERROR, // 0x3d\n    ERROR, // 0x3e\n    ERROR, // 0x3f\n    // byte string (0x00..0x17 bytes follow)\n    BYTE_STRING, // 0x40\n    BYTE_STRING, // 0x41\n    BYTE_STRING, // 0x42\n    BYTE_STRING, // 0x43\n    BYTE_STRING, // 0x44\n    BYTE_STRING, // 0x45\n    BYTE_STRING, // 0x46\n    BYTE_STRING, // 0x47\n    BYTE_STRING, // 0x48\n    BYTE_STRING, // 0x49\n    BYTE_STRING, // 0x4A\n    BYTE_STRING, // 0x4B\n    BYTE_STRING, // 0x4C\n    BYTE_STRING, // 0x4D\n    BYTE_STRING, // 0x4E\n    BYTE_STRING, // 0x4F\n    BYTE_STRING, // 0x50\n    BYTE_STRING, // 0x51\n    BYTE_STRING, // 0x52\n    BYTE_STRING, // 0x53\n    BYTE_STRING, // 0x54\n    BYTE_STRING, // 0x55\n    BYTE_STRING, // 0x56\n    BYTE_STRING, // 0x57\n    // byte string (one-byte uint8_t for n, and then n bytes follow)\n    BYTE_STRING_8, // 0x58\n    // byte string (two-byte uint16_t for n, and then n bytes follow)\n    BYTE_STRING_16, // 0x59\n    // byte string (four-byte uint32_t for n, and then n bytes follow)\n    BYTE_STRING_32, // 0x5a\n    // byte string (eight-byte uint64_t for n, and then n bytes follow)\n    BYTE_STRING_64, // 0x5b\n    ERROR, // 0x5c\n    ERROR, // 0x5d\n    ERROR, // 0x5e\n    // byte string, byte strings follow, terminated by \"break\"\n    BYTE_STRING_BREAK, // 0x5f\n    // UTF-8 string (0x00..0x17 bytes follow)\n    UTF8_STRING, // 0x60\n    UTF8_STRING, // 0x61\n    UTF8_STRING, // 0x62\n    UTF8_STRING, // 0x63\n    UTF8_STRING, // 0x64\n    UTF8_STRING, // 0x65\n    UTF8_STRING, // 0x66\n    UTF8_STRING, // 0x67\n    UTF8_STRING, // 0x68\n    UTF8_STRING, // 0x69\n    UTF8_STRING, // 0x6A\n    UTF8_STRING, // 0x6B\n    UTF8_STRING, // 0x6C\n    UTF8_STRING, // 0x6D\n    UTF8_STRING, // 0x6E\n    UTF8_STRING, // 0x6F\n    UTF8_STRING, // 0x70\n    UTF8_STRING, // 0x71\n    UTF8_STRING, // 0x72\n    UTF8_STRING, // 0x73\n    UTF8_STRING, // 0x74\n    UTF8_STRING, // 0x75\n    UTF8_STRING, // 0x76\n    UTF8_STRING, // 0x77\n    // UTF-8 string (one-byte uint8_t for n, and then n bytes follow)\n    UTF8_STRING_8, // 0x78\n    // UTF-8 string (two-byte uint16_t for n, and then n bytes follow)\n    UTF8_STRING_16, // 0x79\n    // UTF-8 string (four-byte uint32_t for n, and then n bytes follow)\n    UTF8_STRING_32, // 0x7a\n    // UTF-8 string (eight-byte uint64_t for n, and then n bytes follow)\n    UTF8_STRING_64, // 0x7b\n    // UTF-8 string, UTF-8 strings follow, terminated by \"break\"\n    ERROR, // 0x7c\n    ERROR, // 0x7d\n    ERROR, // 0x7e\n    UTF8_STRING_BREAK, // 0x7f\n    // array (0x00..0x17 data items follow)\n    ARRAY, // 0x80\n    ARRAY, // 0x81\n    ARRAY, // 0x82\n    ARRAY, // 0x83\n    ARRAY, // 0x84\n    ARRAY, // 0x85\n    ARRAY, // 0x86\n    ARRAY, // 0x87\n    ARRAY, // 0x88\n    ARRAY, // 0x89\n    ARRAY, // 0x8A\n    ARRAY, // 0x8B\n    ARRAY, // 0x8C\n    ARRAY, // 0x8D\n    ARRAY, // 0x8E\n    ARRAY, // 0x8F\n    ARRAY, // 0x90\n    ARRAY, // 0x91\n    ARRAY, // 0x92\n    ARRAY, // 0x93\n    ARRAY, // 0x94\n    ARRAY, // 0x95\n    ARRAY, // 0x96\n    ARRAY, // 0x97\n    // array (one-byte uint8_t fo, and then n data items follow)\n    ARRAY_8, // 0x98\n    // array (two-byte uint16_t for n, and then n data items follow)\n    ARRAY_16, // 0x99\n    // array (four-byte uint32_t for n, and then n data items follow)\n    ARRAY_32, // 0x9a\n    // array (eight-byte uint64_t for n, and then n data items follow)\n    ARRAY_64, // 0x9b\n    // array, data items follow, terminated by \"break\"\n    ERROR, // 0x9c\n    ERROR, // 0x9d\n    ERROR, // 0x9e\n    ARRAY_BREAK, // 0x9f\n    // map (0x00..0x17 pairs of data items follow)\n    MAP, // 0xa0\n    MAP, // 0xa1\n    MAP, // 0xa2\n    MAP, // 0xa3\n    MAP, // 0xa4\n    MAP, // 0xa5\n    MAP, // 0xa6\n    MAP, // 0xa7\n    MAP, // 0xa8\n    MAP, // 0xa9\n    MAP, // 0xaA\n    MAP, // 0xaB\n    MAP, // 0xaC\n    MAP, // 0xaD\n    MAP, // 0xaE\n    MAP, // 0xaF\n    MAP, // 0xb0\n    MAP, // 0xb1\n    MAP, // 0xb2\n    MAP, // 0xb3\n    MAP, // 0xb4\n    MAP, // 0xb5\n    MAP, // 0xb6\n    MAP, // 0xb7\n    // map (one-byte uint8_t for n, and then n pairs of data items follow)\n    MAP_8, // 0xb8\n    // map (two-byte uint16_t for n, and then n pairs of data items follow)\n    MAP_16, // 0xb9\n    // map (four-byte uint32_t for n, and then n pairs of data items follow)\n    MAP_32, // 0xba\n    // map (eight-byte uint64_t for n, and then n pairs of data items follow)\n    MAP_64, // 0xbb\n    ERROR, // 0xbc\n    ERROR, // 0xbd\n    ERROR, // 0xbe\n    // map, pairs of data items follow, terminated by \"break\"\n    MAP_BREAK, // 0xbf\n    // Text-based date/time (data item follows; see Section 2.4.1)\n    TAG_KNOWN, // 0xc0\n    // Epoch-based date/time (data item follows; see Section 2.4.1)\n    TAG_KNOWN, // 0xc1\n    // Positive bignum (data item \"byte string\" follows)\n    TAG_KNOWN, // 0xc2\n    // Negative bignum (data item \"byte string\" follows)\n    TAG_KNOWN, // 0xc3\n    // Decimal Fraction (data item \"array\" follows; see Section 2.4.3)\n    TAG_KNOWN, // 0xc4\n    // Bigfloat (data item \"array\" follows; see Section 2.4.3)\n    TAG_KNOWN, // 0xc5\n    // (tagged item)\n    TAG_UNASSIGNED, // 0xc6\n    TAG_UNASSIGNED, // 0xc7\n    TAG_UNASSIGNED, // 0xc8\n    TAG_UNASSIGNED, // 0xc9\n    TAG_UNASSIGNED, // 0xca\n    TAG_UNASSIGNED, // 0xcb\n    TAG_UNASSIGNED, // 0xcc\n    TAG_UNASSIGNED, // 0xcd\n    TAG_UNASSIGNED, // 0xce\n    TAG_UNASSIGNED, // 0xcf\n    TAG_UNASSIGNED, // 0xd0\n    TAG_UNASSIGNED, // 0xd1\n    TAG_UNASSIGNED, // 0xd2\n    TAG_UNASSIGNED, // 0xd3\n    TAG_UNASSIGNED, // 0xd4\n    // Expected Conversion (data item follows; see Section 2.4.4.2)\n    TAG_UNASSIGNED, // 0xd5\n    TAG_UNASSIGNED, // 0xd6\n    TAG_UNASSIGNED, // 0xd7\n    // (more tagged items, 1/2/4/8 bytes and then a data item follow)\n    TAG_MORE_1, // 0xd8\n    TAG_MORE_2, // 0xd9\n    TAG_MORE_4, // 0xda\n    TAG_MORE_8, // 0xdb\n    ERROR, // 0xdc\n    ERROR, // 0xdd\n    ERROR, // 0xde\n    ERROR, // 0xdf\n    // (simple value)\n    SIMPLE_UNASSIGNED, // 0xe0\n    SIMPLE_UNASSIGNED, // 0xe1\n    SIMPLE_UNASSIGNED, // 0xe2\n    SIMPLE_UNASSIGNED, // 0xe3\n    SIMPLE_UNASSIGNED, // 0xe4\n    SIMPLE_UNASSIGNED, // 0xe5\n    SIMPLE_UNASSIGNED, // 0xe6\n    SIMPLE_UNASSIGNED, // 0xe7\n    SIMPLE_UNASSIGNED, // 0xe8\n    SIMPLE_UNASSIGNED, // 0xe9\n    SIMPLE_UNASSIGNED, // 0xea\n    SIMPLE_UNASSIGNED, // 0xeb\n    SIMPLE_UNASSIGNED, // 0xec\n    SIMPLE_UNASSIGNED, // 0xed\n    SIMPLE_UNASSIGNED, // 0xee\n    SIMPLE_UNASSIGNED, // 0xef\n    SIMPLE_UNASSIGNED, // 0xf0\n    SIMPLE_UNASSIGNED, // 0xf1\n    SIMPLE_UNASSIGNED, // 0xf2\n    SIMPLE_UNASSIGNED, // 0xf3\n    // False\n    SIMPLE_FALSE, // 0xf4\n    // True\n    SIMPLE_TRUE, // 0xf5\n    // Null\n    SIMPLE_NULL, // 0xf6\n    // Undefined\n    SIMPLE_UNDEFINED, // 0xf7\n    // (simple value, one byte follows)\n    SIMPLE_BYTE, // 0xf8\n    // Half-Precision Float (two-byte IEEE 754)\n    SIMPLE_FLOAT_HALF, // 0xf9\n    // Single-Precision Float (four-byte IEEE 754)\n    SIMPLE_FLOAT_SINGLE, // 0xfa\n    // Double-Precision Float (eight-byte IEEE 754)\n    SIMPLE_FLOAT_DOUBLE, // 0xfb\n    ERROR, // 0xfc\n    ERROR, // 0xfd\n    ERROR, // 0xfe\n    // \"break\" stop code\n    BREAK // 0xff\n  ]\n\n  // --\n\n  return {\n    parse: parse\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2RlY29kZXIuYXNtLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL25vYm9keTEvV29yay9xM3gvc2NhZmZvbGQtaWNwL25vZGVfbW9kdWxlcy9ib3JjL3NyYy9kZWNvZGVyLmFzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlY29kZUFzbSAoc3RkbGliLCBmb3JlaWduLCBidWZmZXIpIHtcbiAgJ3VzZSBhc20nXG5cbiAgLy8gLS0gSW1wb3J0c1xuXG4gIHZhciBoZWFwID0gbmV3IHN0ZGxpYi5VaW50OEFycmF5KGJ1ZmZlcilcbiAgLy8gdmFyIGxvZyA9IGZvcmVpZ24ubG9nXG4gIHZhciBwdXNoSW50ID0gZm9yZWlnbi5wdXNoSW50XG4gIHZhciBwdXNoSW50MzIgPSBmb3JlaWduLnB1c2hJbnQzMlxuICB2YXIgcHVzaEludDMyTmVnID0gZm9yZWlnbi5wdXNoSW50MzJOZWdcbiAgdmFyIHB1c2hJbnQ2NCA9IGZvcmVpZ24ucHVzaEludDY0XG4gIHZhciBwdXNoSW50NjROZWcgPSBmb3JlaWduLnB1c2hJbnQ2NE5lZ1xuICB2YXIgcHVzaEZsb2F0ID0gZm9yZWlnbi5wdXNoRmxvYXRcbiAgdmFyIHB1c2hGbG9hdFNpbmdsZSA9IGZvcmVpZ24ucHVzaEZsb2F0U2luZ2xlXG4gIHZhciBwdXNoRmxvYXREb3VibGUgPSBmb3JlaWduLnB1c2hGbG9hdERvdWJsZVxuICB2YXIgcHVzaFRydWUgPSBmb3JlaWduLnB1c2hUcnVlXG4gIHZhciBwdXNoRmFsc2UgPSBmb3JlaWduLnB1c2hGYWxzZVxuICB2YXIgcHVzaFVuZGVmaW5lZCA9IGZvcmVpZ24ucHVzaFVuZGVmaW5lZFxuICB2YXIgcHVzaE51bGwgPSBmb3JlaWduLnB1c2hOdWxsXG4gIHZhciBwdXNoSW5maW5pdHkgPSBmb3JlaWduLnB1c2hJbmZpbml0eVxuICB2YXIgcHVzaEluZmluaXR5TmVnID0gZm9yZWlnbi5wdXNoSW5maW5pdHlOZWdcbiAgdmFyIHB1c2hOYU4gPSBmb3JlaWduLnB1c2hOYU5cbiAgdmFyIHB1c2hOYU5OZWcgPSBmb3JlaWduLnB1c2hOYU5OZWdcblxuICB2YXIgcHVzaEFycmF5U3RhcnQgPSBmb3JlaWduLnB1c2hBcnJheVN0YXJ0XG4gIHZhciBwdXNoQXJyYXlTdGFydEZpeGVkID0gZm9yZWlnbi5wdXNoQXJyYXlTdGFydEZpeGVkXG4gIHZhciBwdXNoQXJyYXlTdGFydEZpeGVkMzIgPSBmb3JlaWduLnB1c2hBcnJheVN0YXJ0Rml4ZWQzMlxuICB2YXIgcHVzaEFycmF5U3RhcnRGaXhlZDY0ID0gZm9yZWlnbi5wdXNoQXJyYXlTdGFydEZpeGVkNjRcbiAgdmFyIHB1c2hPYmplY3RTdGFydCA9IGZvcmVpZ24ucHVzaE9iamVjdFN0YXJ0XG4gIHZhciBwdXNoT2JqZWN0U3RhcnRGaXhlZCA9IGZvcmVpZ24ucHVzaE9iamVjdFN0YXJ0Rml4ZWRcbiAgdmFyIHB1c2hPYmplY3RTdGFydEZpeGVkMzIgPSBmb3JlaWduLnB1c2hPYmplY3RTdGFydEZpeGVkMzJcbiAgdmFyIHB1c2hPYmplY3RTdGFydEZpeGVkNjQgPSBmb3JlaWduLnB1c2hPYmplY3RTdGFydEZpeGVkNjRcblxuICB2YXIgcHVzaEJ5dGVTdHJpbmcgPSBmb3JlaWduLnB1c2hCeXRlU3RyaW5nXG4gIHZhciBwdXNoQnl0ZVN0cmluZ1N0YXJ0ID0gZm9yZWlnbi5wdXNoQnl0ZVN0cmluZ1N0YXJ0XG4gIHZhciBwdXNoVXRmOFN0cmluZyA9IGZvcmVpZ24ucHVzaFV0ZjhTdHJpbmdcbiAgdmFyIHB1c2hVdGY4U3RyaW5nU3RhcnQgPSBmb3JlaWduLnB1c2hVdGY4U3RyaW5nU3RhcnRcblxuICB2YXIgcHVzaFNpbXBsZVVuYXNzaWduZWQgPSBmb3JlaWduLnB1c2hTaW1wbGVVbmFzc2lnbmVkXG5cbiAgdmFyIHB1c2hUYWdTdGFydCA9IGZvcmVpZ24ucHVzaFRhZ1N0YXJ0XG4gIHZhciBwdXNoVGFnU3RhcnQ0ID0gZm9yZWlnbi5wdXNoVGFnU3RhcnQ0XG4gIHZhciBwdXNoVGFnU3RhcnQ4ID0gZm9yZWlnbi5wdXNoVGFnU3RhcnQ4XG4gIHZhciBwdXNoVGFnVW5hc3NpZ25lZCA9IGZvcmVpZ24ucHVzaFRhZ1VuYXNzaWduZWRcblxuICB2YXIgcHVzaEJyZWFrID0gZm9yZWlnbi5wdXNoQnJlYWtcblxuICB2YXIgcG93ID0gc3RkbGliLk1hdGgucG93XG5cbiAgLy8gLS0gQ29uc3RhbnRzXG5cblxuICAvLyAtLSBNdXRhYmxlIFZhcmlhYmxlc1xuXG4gIHZhciBvZmZzZXQgPSAwXG4gIHZhciBpbnB1dExlbmd0aCA9IDBcbiAgdmFyIGNvZGUgPSAwXG5cbiAgLy8gRGVjb2RlIGEgY2JvciBzdHJpbmcgcmVwcmVzZW50ZWQgYXMgVWludDhBcnJheVxuICAvLyB3aGljaCBpcyBhbGxvY2F0ZWQgb24gdGhlIGhlYXAgZnJvbSAwIHRvIGlucHV0TGVuZ3RoXG4gIC8vXG4gIC8vIGlucHV0IC0gSW50XG4gIC8vXG4gIC8vIFJldHVybnMgQ29kZSAtIEludCxcbiAgLy8gU3VjY2VzcyA9IDBcbiAgLy8gRXJyb3IgPiAwXG4gIGZ1bmN0aW9uIHBhcnNlIChpbnB1dCkge1xuICAgIGlucHV0ID0gaW5wdXQgfCAwXG5cbiAgICBvZmZzZXQgPSAwXG4gICAgaW5wdXRMZW5ndGggPSBpbnB1dFxuXG4gICAgd2hpbGUgKChvZmZzZXQgfCAwKSA8IChpbnB1dExlbmd0aCB8IDApKSB7XG4gICAgICBjb2RlID0ganVtcFRhYmxlW2hlYXBbb2Zmc2V0XSAmIDI1NV0oaGVhcFtvZmZzZXRdIHwgMCkgfCAwXG5cbiAgICAgIGlmICgoY29kZSB8IDApID4gMCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb2RlIHwgMFxuICB9XG5cbiAgLy8gLS0gSGVscGVyIEZ1bmN0aW9uXG5cbiAgZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG4pIHtcbiAgICBuID0gbiB8IDBcblxuICAgIGlmICgoKChvZmZzZXQgfCAwKSArIChuIHwgMCkpIHwgMCkgPCAoaW5wdXRMZW5ndGggfCAwKSkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICByZXR1cm4gMVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFVJbnQxNiAobikge1xuICAgIG4gPSBuIHwgMFxuXG4gICAgcmV0dXJuIChcbiAgICAgIChoZWFwW24gfCAwXSA8PCA4KSB8IGhlYXBbKG4gKyAxKSB8IDBdXG4gICAgKSB8IDBcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRVSW50MzIgKG4pIHtcbiAgICBuID0gbiB8IDBcblxuICAgIHJldHVybiAoXG4gICAgICAoaGVhcFtuIHwgMF0gPDwgMjQpIHwgKGhlYXBbKG4gKyAxKSB8IDBdIDw8IDE2KSB8IChoZWFwWyhuICsgMikgfCAwXSA8PCA4KSB8IGhlYXBbKG4gKyAzKSB8IDBdXG4gICAgKSB8IDBcbiAgfVxuXG4gIC8vIC0tIEluaXRpYWwgQnl0ZSBIYW5kbGVyc1xuXG4gIGZ1bmN0aW9uIElOVF9QIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoSW50KG9jdGV0IHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVSU5UX1BfOCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDEpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoSW50KGhlYXBbKG9mZnNldCArIDEpIHwgMF0gfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDIpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFVJTlRfUF8xNiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDIpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoSW50KFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMykgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVUlOVF9QXzMyIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoNCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hJbnQzMihcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMykgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgNSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVUlOVF9QXzY0IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoOCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hJbnQ2NChcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMykgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyA1KSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDcpIHwgMCkgfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDkpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIElOVF9OIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoSW50KCgtMSAtICgob2N0ZXQgLSAzMikgfCAwKSkgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFVJTlRfTl84IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMSkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hJbnQoXG4gICAgICAoLTEgLSAoaGVhcFsob2Zmc2V0ICsgMSkgfCAwXSB8IDApKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMikgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVUlOVF9OXzE2IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICB2YXIgdmFsID0gMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDIpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICB2YWwgPSByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMFxuICAgIHB1c2hJbnQoKC0xIC0gKHZhbCB8IDApKSB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMykgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVUlOVF9OXzMyIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoNCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hJbnQzMk5lZyhcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMykgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgNSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVUlOVF9OXzY0IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoOCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hJbnQ2NE5lZyhcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMykgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyA1KSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDcpIHwgMCkgfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDkpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIEJZVEVfU1RSSU5HIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICB2YXIgc3RhcnQgPSAwXG4gICAgdmFyIGVuZCA9IDBcbiAgICB2YXIgc3RlcCA9IDBcblxuICAgIHN0ZXAgPSAob2N0ZXQgLSA2NCkgfCAwXG4gICAgaWYgKGNoZWNrT2Zmc2V0KHN0ZXAgfCAwKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgc3RhcnQgPSAob2Zmc2V0ICsgMSkgfCAwXG4gICAgZW5kID0gKCgob2Zmc2V0ICsgMSkgfCAwKSArIChzdGVwIHwgMCkpIHwgMFxuXG4gICAgcHVzaEJ5dGVTdHJpbmcoc3RhcnQgfCAwLCBlbmQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gZW5kIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIEJZVEVfU1RSSU5HXzggKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHZhciBzdGFydCA9IDBcbiAgICB2YXIgZW5kID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMSkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGxlbmd0aCA9IGhlYXBbKG9mZnNldCArIDEpIHwgMF0gfCAwXG4gICAgc3RhcnQgPSAob2Zmc2V0ICsgMikgfCAwXG4gICAgZW5kID0gKCgob2Zmc2V0ICsgMikgfCAwKSArIChsZW5ndGggfCAwKSkgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoKGxlbmd0aCArIDEpIHwgMCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hCeXRlU3RyaW5nKHN0YXJ0IHwgMCwgZW5kIHwgMClcblxuICAgIG9mZnNldCA9IGVuZCB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBCWVRFX1NUUklOR18xNiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgdmFyIHN0YXJ0ID0gMFxuICAgIHZhciBlbmQgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcblxuICAgIGlmIChjaGVja09mZnNldCgyKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgbGVuZ3RoID0gcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDBcbiAgICBzdGFydCA9IChvZmZzZXQgKyAzKSB8IDBcbiAgICBlbmQgPSAoKChvZmZzZXQgKyAzKSB8IDApICsgKGxlbmd0aCB8IDApKSB8IDBcblxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KChsZW5ndGggKyAyKSB8IDApIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoQnl0ZVN0cmluZyhzdGFydCB8IDAsIGVuZCB8IDApXG5cbiAgICBvZmZzZXQgPSBlbmQgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gQllURV9TVFJJTkdfMzIgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHZhciBzdGFydCA9IDBcbiAgICB2YXIgZW5kID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoNCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGxlbmd0aCA9IHJlYWRVSW50MzIoKG9mZnNldCArIDEpIHwgMCkgfCAwXG4gICAgc3RhcnQgPSAob2Zmc2V0ICsgNSkgfCAwXG4gICAgZW5kID0gKCgob2Zmc2V0ICsgNSkgfCAwKSArIChsZW5ndGggfCAwKSkgfCAwXG5cblxuICAgIGlmIChjaGVja09mZnNldCgobGVuZ3RoICsgNCkgfCAwKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEJ5dGVTdHJpbmcoc3RhcnQgfCAwLCBlbmQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gZW5kIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIEJZVEVfU1RSSU5HXzY0IChvY3RldCkge1xuICAgIC8vIE5PVCBJTVBMRU1FTlRFRFxuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICByZXR1cm4gMVxuICB9XG5cbiAgZnVuY3Rpb24gQllURV9TVFJJTkdfQlJFQUsgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hCeXRlU3RyaW5nU3RhcnQoKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFVURjhfU1RSSU5HIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICB2YXIgc3RhcnQgPSAwXG4gICAgdmFyIGVuZCA9IDBcbiAgICB2YXIgc3RlcCA9IDBcblxuICAgIHN0ZXAgPSAob2N0ZXQgLSA5NikgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoc3RlcCB8IDApIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBzdGFydCA9IChvZmZzZXQgKyAxKSB8IDBcbiAgICBlbmQgPSAoKChvZmZzZXQgKyAxKSB8IDApICsgKHN0ZXAgfCAwKSkgfCAwXG5cbiAgICBwdXNoVXRmOFN0cmluZyhzdGFydCB8IDAsIGVuZCB8IDApXG5cbiAgICBvZmZzZXQgPSBlbmQgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVVRGOF9TVFJJTkdfOCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgdmFyIHN0YXJ0ID0gMFxuICAgIHZhciBlbmQgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcblxuICAgIGlmIChjaGVja09mZnNldCgxKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgbGVuZ3RoID0gaGVhcFsob2Zmc2V0ICsgMSkgfCAwXSB8IDBcbiAgICBzdGFydCA9IChvZmZzZXQgKyAyKSB8IDBcbiAgICBlbmQgPSAoKChvZmZzZXQgKyAyKSB8IDApICsgKGxlbmd0aCB8IDApKSB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgobGVuZ3RoICsgMSkgfCAwKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaFV0ZjhTdHJpbmcoc3RhcnQgfCAwLCBlbmQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gZW5kIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFVURjhfU1RSSU5HXzE2IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICB2YXIgc3RhcnQgPSAwXG4gICAgdmFyIGVuZCA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDIpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBsZW5ndGggPSByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMFxuICAgIHN0YXJ0ID0gKG9mZnNldCArIDMpIHwgMFxuICAgIGVuZCA9ICgoKG9mZnNldCArIDMpIHwgMCkgKyAobGVuZ3RoIHwgMCkpIHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KChsZW5ndGggKyAyKSB8IDApIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoVXRmOFN0cmluZyhzdGFydCB8IDAsIGVuZCB8IDApXG5cbiAgICBvZmZzZXQgPSBlbmQgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVVRGOF9TVFJJTkdfMzIgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHZhciBzdGFydCA9IDBcbiAgICB2YXIgZW5kID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoNCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGxlbmd0aCA9IHJlYWRVSW50MzIoKG9mZnNldCArIDEpIHwgMCkgfCAwXG4gICAgc3RhcnQgPSAob2Zmc2V0ICsgNSkgfCAwXG4gICAgZW5kID0gKCgob2Zmc2V0ICsgNSkgfCAwKSArIChsZW5ndGggfCAwKSkgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoKGxlbmd0aCArIDQpIHwgMCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hVdGY4U3RyaW5nKHN0YXJ0IHwgMCwgZW5kIHwgMClcblxuICAgIG9mZnNldCA9IGVuZCB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVVEY4X1NUUklOR182NCAob2N0ZXQpIHtcbiAgICAvLyBOT1QgSU1QTEVNRU5URURcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIGZ1bmN0aW9uIFVURjhfU1RSSU5HX0JSRUFLIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoVXRmOFN0cmluZ1N0YXJ0KClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBBUlJBWSAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaEFycmF5U3RhcnRGaXhlZCgob2N0ZXQgLSAxMjgpIHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBBUlJBWV84IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMSkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hBcnJheVN0YXJ0Rml4ZWQoaGVhcFsob2Zmc2V0ICsgMSkgfCAwXSB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMikgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gQVJSQVlfMTYgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgyKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEFycmF5U3RhcnRGaXhlZChcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDMpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIEFSUkFZXzMyIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoNCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hBcnJheVN0YXJ0Rml4ZWQzMihcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMykgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgNSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gQVJSQVlfNjQgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg4KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEFycmF5U3RhcnRGaXhlZDY0KFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAzKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDUpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgNykgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgOSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gQVJSQVlfQlJFQUsgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hBcnJheVN0YXJ0KClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBNQVAgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHZhciBzdGVwID0gMFxuXG4gICAgc3RlcCA9IChvY3RldCAtIDE2MCkgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoc3RlcCB8IDApIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoT2JqZWN0U3RhcnRGaXhlZChzdGVwIHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBNQVBfOCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDEpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoT2JqZWN0U3RhcnRGaXhlZChoZWFwWyhvZmZzZXQgKyAxKSB8IDBdIHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAyKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBNQVBfMTYgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgyKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaE9iamVjdFN0YXJ0Rml4ZWQoXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAzKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBNQVBfMzIgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg0KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaE9iamVjdFN0YXJ0Rml4ZWQzMihcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMykgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgNSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gTUFQXzY0IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoOCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hPYmplY3RTdGFydEZpeGVkNjQoXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDMpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgNSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyA3KSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyA5KSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBNQVBfQlJFQUsgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hPYmplY3RTdGFydCgpXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX0tOT1dOIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoVGFnU3RhcnQoKG9jdGV0IC0gMTkyfCAwKSB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX0JJR05VTV9QT1MgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hUYWdTdGFydChvY3RldCB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX0JJR05VTV9ORUcgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hUYWdTdGFydChvY3RldCB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX0ZSQUMgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hUYWdTdGFydChvY3RldCB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX0JJR05VTV9GTE9BVCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFRhZ1N0YXJ0KG9jdGV0IHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxIHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfVU5BU1NJR05FRCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFRhZ1N0YXJ0KChvY3RldCAtIDE5MnwgMCkgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEgfCAwKVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFRBR19CQVNFNjRfVVJMIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoVGFnU3RhcnQob2N0ZXQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEgfCAwKVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFRBR19CQVNFNjQgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hUYWdTdGFydChvY3RldCB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX0JBU0UxNiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFRhZ1N0YXJ0KG9jdGV0IHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxIHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfTU9SRV8xIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMSkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hUYWdTdGFydChoZWFwWyhvZmZzZXQgKyAxKSB8IDBdIHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAyIHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfTU9SRV8yIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMikgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hUYWdTdGFydChcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDMgfCAwKVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFRBR19NT1JFXzQgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg0KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaFRhZ1N0YXJ0NChcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMykgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgNSB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX01PUkVfOCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDgpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoVGFnU3RhcnQ4KFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAzKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDUpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgNykgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgOSB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gU0lNUExFX1VOQVNTSUdORUQgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hTaW1wbGVVbmFzc2lnbmVkKCgob2N0ZXQgfCAwKSAtIDIyNCkgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFNJTVBMRV9GQUxTRSAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaEZhbHNlKClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBTSU1QTEVfVFJVRSAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFRydWUoKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFNJTVBMRV9OVUxMIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoTnVsbCgpXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gU0lNUExFX1VOREVGSU5FRCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFVuZGVmaW5lZCgpXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gU0lNUExFX0JZVEUgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgxKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaFNpbXBsZVVuYXNzaWduZWQoaGVhcFsob2Zmc2V0ICsgMSkgfCAwXSB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMikgIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFNJTVBMRV9GTE9BVF9IQUxGIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICB2YXIgZiA9IDBcbiAgICB2YXIgZyA9IDBcbiAgICB2YXIgc2lnbiA9IDEuMFxuICAgIHZhciBleHAgPSAwLjBcbiAgICB2YXIgbWFudCA9IDAuMFxuICAgIHZhciByID0gMC4wXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDIpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBmID0gaGVhcFsob2Zmc2V0ICsgMSkgfCAwXSB8IDBcbiAgICBnID0gaGVhcFsob2Zmc2V0ICsgMikgfCAwXSB8IDBcblxuICAgIGlmICgoZiB8IDApICYgMHg4MCkge1xuICAgICAgc2lnbiA9IC0xLjBcbiAgICB9XG5cbiAgICBleHAgPSArKCgoZiB8IDApICYgMHg3QykgPj4gMilcbiAgICBtYW50ID0gKygoKChmIHwgMCkgJiAweDAzKSA8PCA4KSB8IGcpXG5cbiAgICBpZiAoK2V4cCA9PSAwLjApIHtcbiAgICAgIHB1c2hGbG9hdCgrKFxuICAgICAgICAoK3NpZ24pICogKzUuOTYwNDY0NDc3NTM5MDYyNWUtOCAqICgrbWFudClcbiAgICAgICkpXG4gICAgfSBlbHNlIGlmICgrZXhwID09IDMxLjApIHtcbiAgICAgIGlmICgrc2lnbiA9PSAxLjApIHtcbiAgICAgICAgaWYgKCttYW50ID4gMC4wKSB7XG4gICAgICAgICAgcHVzaE5hTigpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHVzaEluZmluaXR5KClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCttYW50ID4gMC4wKSB7XG4gICAgICAgICAgcHVzaE5hTk5lZygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHVzaEluZmluaXR5TmVnKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoRmxvYXQoKyhcbiAgICAgICAgK3NpZ24gKiBwb3coKzIsICsoK2V4cCAtIDI1LjApKSAqICsoMTAyNC4wICsgbWFudClcbiAgICAgICkpXG4gICAgfVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDMpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFNJTVBMRV9GTE9BVF9TSU5HTEUgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg0KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEZsb2F0U2luZ2xlKFxuICAgICAgaGVhcFsob2Zmc2V0ICsgMSkgfCAwXSB8IDAsXG4gICAgICBoZWFwWyhvZmZzZXQgKyAyKSB8IDBdIHwgMCxcbiAgICAgIGhlYXBbKG9mZnNldCArIDMpIHwgMF0gfCAwLFxuICAgICAgaGVhcFsob2Zmc2V0ICsgNCkgfCAwXSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgNSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gU0lNUExFX0ZMT0FUX0RPVUJMRSAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDgpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoRmxvYXREb3VibGUoXG4gICAgICBoZWFwWyhvZmZzZXQgKyAxKSB8IDBdIHwgMCxcbiAgICAgIGhlYXBbKG9mZnNldCArIDIpIHwgMF0gfCAwLFxuICAgICAgaGVhcFsob2Zmc2V0ICsgMykgfCAwXSB8IDAsXG4gICAgICBoZWFwWyhvZmZzZXQgKyA0KSB8IDBdIHwgMCxcbiAgICAgIGhlYXBbKG9mZnNldCArIDUpIHwgMF0gfCAwLFxuICAgICAgaGVhcFsob2Zmc2V0ICsgNikgfCAwXSB8IDAsXG4gICAgICBoZWFwWyhvZmZzZXQgKyA3KSB8IDBdIHwgMCxcbiAgICAgIGhlYXBbKG9mZnNldCArIDgpIHwgMF0gfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDkpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIEVSUk9SIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICByZXR1cm4gMVxuICB9XG5cbiAgZnVuY3Rpb24gQlJFQUsgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hCcmVhaygpXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgLy8gLS0gSnVtcCBUYWJsZVxuXG4gIHZhciBqdW1wVGFibGUgPSBbXG4gICAgLy8gSW50ZWdlciAweDAwLi4weDE3ICgwLi4yMylcbiAgICBJTlRfUCwgLy8gMHgwMFxuICAgIElOVF9QLCAvLyAweDAxXG4gICAgSU5UX1AsIC8vIDB4MDJcbiAgICBJTlRfUCwgLy8gMHgwM1xuICAgIElOVF9QLCAvLyAweDA0XG4gICAgSU5UX1AsIC8vIDB4MDVcbiAgICBJTlRfUCwgLy8gMHgwNlxuICAgIElOVF9QLCAvLyAweDA3XG4gICAgSU5UX1AsIC8vIDB4MDhcbiAgICBJTlRfUCwgLy8gMHgwOVxuICAgIElOVF9QLCAvLyAweDBBXG4gICAgSU5UX1AsIC8vIDB4MEJcbiAgICBJTlRfUCwgLy8gMHgwQ1xuICAgIElOVF9QLCAvLyAweDBEXG4gICAgSU5UX1AsIC8vIDB4MEVcbiAgICBJTlRfUCwgLy8gMHgwRlxuICAgIElOVF9QLCAvLyAweDEwXG4gICAgSU5UX1AsIC8vIDB4MTFcbiAgICBJTlRfUCwgLy8gMHgxMlxuICAgIElOVF9QLCAvLyAweDEzXG4gICAgSU5UX1AsIC8vIDB4MTRcbiAgICBJTlRfUCwgLy8gMHgxNVxuICAgIElOVF9QLCAvLyAweDE2XG4gICAgSU5UX1AsIC8vIDB4MTdcbiAgICAvLyBVbnNpZ25lZCBpbnRlZ2VyIChvbmUtYnl0ZSB1aW50OF90IGZvbGxvd3MpXG4gICAgVUlOVF9QXzgsIC8vIDB4MThcbiAgICAvLyBVbnNpZ25lZCBpbnRlZ2VyICh0d28tYnl0ZSB1aW50MTZfdCBmb2xsb3dzKVxuICAgIFVJTlRfUF8xNiwgLy8gMHgxOVxuICAgIC8vIFVuc2lnbmVkIGludGVnZXIgKGZvdXItYnl0ZSB1aW50MzJfdCBmb2xsb3dzKVxuICAgIFVJTlRfUF8zMiwgLy8gMHgxYVxuICAgIC8vIFVuc2lnbmVkIGludGVnZXIgKGVpZ2h0LWJ5dGUgdWludDY0X3QgZm9sbG93cylcbiAgICBVSU5UX1BfNjQsIC8vIDB4MWJcbiAgICBFUlJPUiwgLy8gMHgxY1xuICAgIEVSUk9SLCAvLyAweDFkXG4gICAgRVJST1IsIC8vIDB4MWVcbiAgICBFUlJPUiwgLy8gMHgxZlxuICAgIC8vIE5lZ2F0aXZlIGludGVnZXIgLTEtMHgwMC4uLTEtMHgxNyAoLTEuLi0yNClcbiAgICBJTlRfTiwgLy8gMHgyMFxuICAgIElOVF9OLCAvLyAweDIxXG4gICAgSU5UX04sIC8vIDB4MjJcbiAgICBJTlRfTiwgLy8gMHgyM1xuICAgIElOVF9OLCAvLyAweDI0XG4gICAgSU5UX04sIC8vIDB4MjVcbiAgICBJTlRfTiwgLy8gMHgyNlxuICAgIElOVF9OLCAvLyAweDI3XG4gICAgSU5UX04sIC8vIDB4MjhcbiAgICBJTlRfTiwgLy8gMHgyOVxuICAgIElOVF9OLCAvLyAweDJBXG4gICAgSU5UX04sIC8vIDB4MkJcbiAgICBJTlRfTiwgLy8gMHgyQ1xuICAgIElOVF9OLCAvLyAweDJEXG4gICAgSU5UX04sIC8vIDB4MkVcbiAgICBJTlRfTiwgLy8gMHgyRlxuICAgIElOVF9OLCAvLyAweDMwXG4gICAgSU5UX04sIC8vIDB4MzFcbiAgICBJTlRfTiwgLy8gMHgzMlxuICAgIElOVF9OLCAvLyAweDMzXG4gICAgSU5UX04sIC8vIDB4MzRcbiAgICBJTlRfTiwgLy8gMHgzNVxuICAgIElOVF9OLCAvLyAweDM2XG4gICAgSU5UX04sIC8vIDB4MzdcbiAgICAvLyBOZWdhdGl2ZSBpbnRlZ2VyIC0xLW4gKG9uZS1ieXRlIHVpbnQ4X3QgZm9yIG4gZm9sbG93cylcbiAgICBVSU5UX05fOCwgLy8gMHgzOFxuICAgIC8vIE5lZ2F0aXZlIGludGVnZXIgLTEtbiAodHdvLWJ5dGUgdWludDE2X3QgZm9yIG4gZm9sbG93cylcbiAgICBVSU5UX05fMTYsIC8vIDB4MzlcbiAgICAvLyBOZWdhdGl2ZSBpbnRlZ2VyIC0xLW4gKGZvdXItYnl0ZSB1aW50MzJfdCBmb3IgbmZvbGxvd3MpXG4gICAgVUlOVF9OXzMyLCAvLyAweDNhXG4gICAgLy8gTmVnYXRpdmUgaW50ZWdlciAtMS1uIChlaWdodC1ieXRlIHVpbnQ2NF90IGZvciBuIGZvbGxvd3MpXG4gICAgVUlOVF9OXzY0LCAvLyAweDNiXG4gICAgRVJST1IsIC8vIDB4M2NcbiAgICBFUlJPUiwgLy8gMHgzZFxuICAgIEVSUk9SLCAvLyAweDNlXG4gICAgRVJST1IsIC8vIDB4M2ZcbiAgICAvLyBieXRlIHN0cmluZyAoMHgwMC4uMHgxNyBieXRlcyBmb2xsb3cpXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NDBcbiAgICBCWVRFX1NUUklORywgLy8gMHg0MVxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDQyXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NDNcbiAgICBCWVRFX1NUUklORywgLy8gMHg0NFxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDQ1XG4gICAgQllURV9TVFJJTkcsIC8vIDB4NDZcbiAgICBCWVRFX1NUUklORywgLy8gMHg0N1xuICAgIEJZVEVfU1RSSU5HLCAvLyAweDQ4XG4gICAgQllURV9TVFJJTkcsIC8vIDB4NDlcbiAgICBCWVRFX1NUUklORywgLy8gMHg0QVxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDRCXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NENcbiAgICBCWVRFX1NUUklORywgLy8gMHg0RFxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDRFXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NEZcbiAgICBCWVRFX1NUUklORywgLy8gMHg1MFxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDUxXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NTJcbiAgICBCWVRFX1NUUklORywgLy8gMHg1M1xuICAgIEJZVEVfU1RSSU5HLCAvLyAweDU0XG4gICAgQllURV9TVFJJTkcsIC8vIDB4NTVcbiAgICBCWVRFX1NUUklORywgLy8gMHg1NlxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDU3XG4gICAgLy8gYnl0ZSBzdHJpbmcgKG9uZS1ieXRlIHVpbnQ4X3QgZm9yIG4sIGFuZCB0aGVuIG4gYnl0ZXMgZm9sbG93KVxuICAgIEJZVEVfU1RSSU5HXzgsIC8vIDB4NThcbiAgICAvLyBieXRlIHN0cmluZyAodHdvLWJ5dGUgdWludDE2X3QgZm9yIG4sIGFuZCB0aGVuIG4gYnl0ZXMgZm9sbG93KVxuICAgIEJZVEVfU1RSSU5HXzE2LCAvLyAweDU5XG4gICAgLy8gYnl0ZSBzdHJpbmcgKGZvdXItYnl0ZSB1aW50MzJfdCBmb3IgbiwgYW5kIHRoZW4gbiBieXRlcyBmb2xsb3cpXG4gICAgQllURV9TVFJJTkdfMzIsIC8vIDB4NWFcbiAgICAvLyBieXRlIHN0cmluZyAoZWlnaHQtYnl0ZSB1aW50NjRfdCBmb3IgbiwgYW5kIHRoZW4gbiBieXRlcyBmb2xsb3cpXG4gICAgQllURV9TVFJJTkdfNjQsIC8vIDB4NWJcbiAgICBFUlJPUiwgLy8gMHg1Y1xuICAgIEVSUk9SLCAvLyAweDVkXG4gICAgRVJST1IsIC8vIDB4NWVcbiAgICAvLyBieXRlIHN0cmluZywgYnl0ZSBzdHJpbmdzIGZvbGxvdywgdGVybWluYXRlZCBieSBcImJyZWFrXCJcbiAgICBCWVRFX1NUUklOR19CUkVBSywgLy8gMHg1ZlxuICAgIC8vIFVURi04IHN0cmluZyAoMHgwMC4uMHgxNyBieXRlcyBmb2xsb3cpXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NjBcbiAgICBVVEY4X1NUUklORywgLy8gMHg2MVxuICAgIFVURjhfU1RSSU5HLCAvLyAweDYyXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NjNcbiAgICBVVEY4X1NUUklORywgLy8gMHg2NFxuICAgIFVURjhfU1RSSU5HLCAvLyAweDY1XG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NjZcbiAgICBVVEY4X1NUUklORywgLy8gMHg2N1xuICAgIFVURjhfU1RSSU5HLCAvLyAweDY4XG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NjlcbiAgICBVVEY4X1NUUklORywgLy8gMHg2QVxuICAgIFVURjhfU1RSSU5HLCAvLyAweDZCXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NkNcbiAgICBVVEY4X1NUUklORywgLy8gMHg2RFxuICAgIFVURjhfU1RSSU5HLCAvLyAweDZFXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NkZcbiAgICBVVEY4X1NUUklORywgLy8gMHg3MFxuICAgIFVURjhfU1RSSU5HLCAvLyAweDcxXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NzJcbiAgICBVVEY4X1NUUklORywgLy8gMHg3M1xuICAgIFVURjhfU1RSSU5HLCAvLyAweDc0XG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NzVcbiAgICBVVEY4X1NUUklORywgLy8gMHg3NlxuICAgIFVURjhfU1RSSU5HLCAvLyAweDc3XG4gICAgLy8gVVRGLTggc3RyaW5nIChvbmUtYnl0ZSB1aW50OF90IGZvciBuLCBhbmQgdGhlbiBuIGJ5dGVzIGZvbGxvdylcbiAgICBVVEY4X1NUUklOR184LCAvLyAweDc4XG4gICAgLy8gVVRGLTggc3RyaW5nICh0d28tYnl0ZSB1aW50MTZfdCBmb3IgbiwgYW5kIHRoZW4gbiBieXRlcyBmb2xsb3cpXG4gICAgVVRGOF9TVFJJTkdfMTYsIC8vIDB4NzlcbiAgICAvLyBVVEYtOCBzdHJpbmcgKGZvdXItYnl0ZSB1aW50MzJfdCBmb3IgbiwgYW5kIHRoZW4gbiBieXRlcyBmb2xsb3cpXG4gICAgVVRGOF9TVFJJTkdfMzIsIC8vIDB4N2FcbiAgICAvLyBVVEYtOCBzdHJpbmcgKGVpZ2h0LWJ5dGUgdWludDY0X3QgZm9yIG4sIGFuZCB0aGVuIG4gYnl0ZXMgZm9sbG93KVxuICAgIFVURjhfU1RSSU5HXzY0LCAvLyAweDdiXG4gICAgLy8gVVRGLTggc3RyaW5nLCBVVEYtOCBzdHJpbmdzIGZvbGxvdywgdGVybWluYXRlZCBieSBcImJyZWFrXCJcbiAgICBFUlJPUiwgLy8gMHg3Y1xuICAgIEVSUk9SLCAvLyAweDdkXG4gICAgRVJST1IsIC8vIDB4N2VcbiAgICBVVEY4X1NUUklOR19CUkVBSywgLy8gMHg3ZlxuICAgIC8vIGFycmF5ICgweDAwLi4weDE3IGRhdGEgaXRlbXMgZm9sbG93KVxuICAgIEFSUkFZLCAvLyAweDgwXG4gICAgQVJSQVksIC8vIDB4ODFcbiAgICBBUlJBWSwgLy8gMHg4MlxuICAgIEFSUkFZLCAvLyAweDgzXG4gICAgQVJSQVksIC8vIDB4ODRcbiAgICBBUlJBWSwgLy8gMHg4NVxuICAgIEFSUkFZLCAvLyAweDg2XG4gICAgQVJSQVksIC8vIDB4ODdcbiAgICBBUlJBWSwgLy8gMHg4OFxuICAgIEFSUkFZLCAvLyAweDg5XG4gICAgQVJSQVksIC8vIDB4OEFcbiAgICBBUlJBWSwgLy8gMHg4QlxuICAgIEFSUkFZLCAvLyAweDhDXG4gICAgQVJSQVksIC8vIDB4OERcbiAgICBBUlJBWSwgLy8gMHg4RVxuICAgIEFSUkFZLCAvLyAweDhGXG4gICAgQVJSQVksIC8vIDB4OTBcbiAgICBBUlJBWSwgLy8gMHg5MVxuICAgIEFSUkFZLCAvLyAweDkyXG4gICAgQVJSQVksIC8vIDB4OTNcbiAgICBBUlJBWSwgLy8gMHg5NFxuICAgIEFSUkFZLCAvLyAweDk1XG4gICAgQVJSQVksIC8vIDB4OTZcbiAgICBBUlJBWSwgLy8gMHg5N1xuICAgIC8vIGFycmF5IChvbmUtYnl0ZSB1aW50OF90IGZvLCBhbmQgdGhlbiBuIGRhdGEgaXRlbXMgZm9sbG93KVxuICAgIEFSUkFZXzgsIC8vIDB4OThcbiAgICAvLyBhcnJheSAodHdvLWJ5dGUgdWludDE2X3QgZm9yIG4sIGFuZCB0aGVuIG4gZGF0YSBpdGVtcyBmb2xsb3cpXG4gICAgQVJSQVlfMTYsIC8vIDB4OTlcbiAgICAvLyBhcnJheSAoZm91ci1ieXRlIHVpbnQzMl90IGZvciBuLCBhbmQgdGhlbiBuIGRhdGEgaXRlbXMgZm9sbG93KVxuICAgIEFSUkFZXzMyLCAvLyAweDlhXG4gICAgLy8gYXJyYXkgKGVpZ2h0LWJ5dGUgdWludDY0X3QgZm9yIG4sIGFuZCB0aGVuIG4gZGF0YSBpdGVtcyBmb2xsb3cpXG4gICAgQVJSQVlfNjQsIC8vIDB4OWJcbiAgICAvLyBhcnJheSwgZGF0YSBpdGVtcyBmb2xsb3csIHRlcm1pbmF0ZWQgYnkgXCJicmVha1wiXG4gICAgRVJST1IsIC8vIDB4OWNcbiAgICBFUlJPUiwgLy8gMHg5ZFxuICAgIEVSUk9SLCAvLyAweDllXG4gICAgQVJSQVlfQlJFQUssIC8vIDB4OWZcbiAgICAvLyBtYXAgKDB4MDAuLjB4MTcgcGFpcnMgb2YgZGF0YSBpdGVtcyBmb2xsb3cpXG4gICAgTUFQLCAvLyAweGEwXG4gICAgTUFQLCAvLyAweGExXG4gICAgTUFQLCAvLyAweGEyXG4gICAgTUFQLCAvLyAweGEzXG4gICAgTUFQLCAvLyAweGE0XG4gICAgTUFQLCAvLyAweGE1XG4gICAgTUFQLCAvLyAweGE2XG4gICAgTUFQLCAvLyAweGE3XG4gICAgTUFQLCAvLyAweGE4XG4gICAgTUFQLCAvLyAweGE5XG4gICAgTUFQLCAvLyAweGFBXG4gICAgTUFQLCAvLyAweGFCXG4gICAgTUFQLCAvLyAweGFDXG4gICAgTUFQLCAvLyAweGFEXG4gICAgTUFQLCAvLyAweGFFXG4gICAgTUFQLCAvLyAweGFGXG4gICAgTUFQLCAvLyAweGIwXG4gICAgTUFQLCAvLyAweGIxXG4gICAgTUFQLCAvLyAweGIyXG4gICAgTUFQLCAvLyAweGIzXG4gICAgTUFQLCAvLyAweGI0XG4gICAgTUFQLCAvLyAweGI1XG4gICAgTUFQLCAvLyAweGI2XG4gICAgTUFQLCAvLyAweGI3XG4gICAgLy8gbWFwIChvbmUtYnl0ZSB1aW50OF90IGZvciBuLCBhbmQgdGhlbiBuIHBhaXJzIG9mIGRhdGEgaXRlbXMgZm9sbG93KVxuICAgIE1BUF84LCAvLyAweGI4XG4gICAgLy8gbWFwICh0d28tYnl0ZSB1aW50MTZfdCBmb3IgbiwgYW5kIHRoZW4gbiBwYWlycyBvZiBkYXRhIGl0ZW1zIGZvbGxvdylcbiAgICBNQVBfMTYsIC8vIDB4YjlcbiAgICAvLyBtYXAgKGZvdXItYnl0ZSB1aW50MzJfdCBmb3IgbiwgYW5kIHRoZW4gbiBwYWlycyBvZiBkYXRhIGl0ZW1zIGZvbGxvdylcbiAgICBNQVBfMzIsIC8vIDB4YmFcbiAgICAvLyBtYXAgKGVpZ2h0LWJ5dGUgdWludDY0X3QgZm9yIG4sIGFuZCB0aGVuIG4gcGFpcnMgb2YgZGF0YSBpdGVtcyBmb2xsb3cpXG4gICAgTUFQXzY0LCAvLyAweGJiXG4gICAgRVJST1IsIC8vIDB4YmNcbiAgICBFUlJPUiwgLy8gMHhiZFxuICAgIEVSUk9SLCAvLyAweGJlXG4gICAgLy8gbWFwLCBwYWlycyBvZiBkYXRhIGl0ZW1zIGZvbGxvdywgdGVybWluYXRlZCBieSBcImJyZWFrXCJcbiAgICBNQVBfQlJFQUssIC8vIDB4YmZcbiAgICAvLyBUZXh0LWJhc2VkIGRhdGUvdGltZSAoZGF0YSBpdGVtIGZvbGxvd3M7IHNlZSBTZWN0aW9uIDIuNC4xKVxuICAgIFRBR19LTk9XTiwgLy8gMHhjMFxuICAgIC8vIEVwb2NoLWJhc2VkIGRhdGUvdGltZSAoZGF0YSBpdGVtIGZvbGxvd3M7IHNlZSBTZWN0aW9uIDIuNC4xKVxuICAgIFRBR19LTk9XTiwgLy8gMHhjMVxuICAgIC8vIFBvc2l0aXZlIGJpZ251bSAoZGF0YSBpdGVtIFwiYnl0ZSBzdHJpbmdcIiBmb2xsb3dzKVxuICAgIFRBR19LTk9XTiwgLy8gMHhjMlxuICAgIC8vIE5lZ2F0aXZlIGJpZ251bSAoZGF0YSBpdGVtIFwiYnl0ZSBzdHJpbmdcIiBmb2xsb3dzKVxuICAgIFRBR19LTk9XTiwgLy8gMHhjM1xuICAgIC8vIERlY2ltYWwgRnJhY3Rpb24gKGRhdGEgaXRlbSBcImFycmF5XCIgZm9sbG93czsgc2VlIFNlY3Rpb24gMi40LjMpXG4gICAgVEFHX0tOT1dOLCAvLyAweGM0XG4gICAgLy8gQmlnZmxvYXQgKGRhdGEgaXRlbSBcImFycmF5XCIgZm9sbG93czsgc2VlIFNlY3Rpb24gMi40LjMpXG4gICAgVEFHX0tOT1dOLCAvLyAweGM1XG4gICAgLy8gKHRhZ2dlZCBpdGVtKVxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGM2XG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4YzdcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhjOFxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGM5XG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4Y2FcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhjYlxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGNjXG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4Y2RcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhjZVxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGNmXG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4ZDBcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhkMVxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGQyXG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4ZDNcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhkNFxuICAgIC8vIEV4cGVjdGVkIENvbnZlcnNpb24gKGRhdGEgaXRlbSBmb2xsb3dzOyBzZWUgU2VjdGlvbiAyLjQuNC4yKVxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGQ1XG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4ZDZcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhkN1xuICAgIC8vIChtb3JlIHRhZ2dlZCBpdGVtcywgMS8yLzQvOCBieXRlcyBhbmQgdGhlbiBhIGRhdGEgaXRlbSBmb2xsb3cpXG4gICAgVEFHX01PUkVfMSwgLy8gMHhkOFxuICAgIFRBR19NT1JFXzIsIC8vIDB4ZDlcbiAgICBUQUdfTU9SRV80LCAvLyAweGRhXG4gICAgVEFHX01PUkVfOCwgLy8gMHhkYlxuICAgIEVSUk9SLCAvLyAweGRjXG4gICAgRVJST1IsIC8vIDB4ZGRcbiAgICBFUlJPUiwgLy8gMHhkZVxuICAgIEVSUk9SLCAvLyAweGRmXG4gICAgLy8gKHNpbXBsZSB2YWx1ZSlcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlMFxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGUxXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZTJcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlM1xuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGU0XG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZTVcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlNlxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGU3XG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZThcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlOVxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGVhXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZWJcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlY1xuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGVkXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZWVcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlZlxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGYwXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZjFcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhmMlxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGYzXG4gICAgLy8gRmFsc2VcbiAgICBTSU1QTEVfRkFMU0UsIC8vIDB4ZjRcbiAgICAvLyBUcnVlXG4gICAgU0lNUExFX1RSVUUsIC8vIDB4ZjVcbiAgICAvLyBOdWxsXG4gICAgU0lNUExFX05VTEwsIC8vIDB4ZjZcbiAgICAvLyBVbmRlZmluZWRcbiAgICBTSU1QTEVfVU5ERUZJTkVELCAvLyAweGY3XG4gICAgLy8gKHNpbXBsZSB2YWx1ZSwgb25lIGJ5dGUgZm9sbG93cylcbiAgICBTSU1QTEVfQllURSwgLy8gMHhmOFxuICAgIC8vIEhhbGYtUHJlY2lzaW9uIEZsb2F0ICh0d28tYnl0ZSBJRUVFIDc1NClcbiAgICBTSU1QTEVfRkxPQVRfSEFMRiwgLy8gMHhmOVxuICAgIC8vIFNpbmdsZS1QcmVjaXNpb24gRmxvYXQgKGZvdXItYnl0ZSBJRUVFIDc1NClcbiAgICBTSU1QTEVfRkxPQVRfU0lOR0xFLCAvLyAweGZhXG4gICAgLy8gRG91YmxlLVByZWNpc2lvbiBGbG9hdCAoZWlnaHQtYnl0ZSBJRUVFIDc1NClcbiAgICBTSU1QTEVfRkxPQVRfRE9VQkxFLCAvLyAweGZiXG4gICAgRVJST1IsIC8vIDB4ZmNcbiAgICBFUlJPUiwgLy8gMHhmZFxuICAgIEVSUk9SLCAvLyAweGZlXG4gICAgLy8gXCJicmVha1wiIHN0b3AgY29kZVxuICAgIEJSRUFLIC8vIDB4ZmZcbiAgXVxuXG4gIC8vIC0tXG5cbiAgcmV0dXJuIHtcbiAgICBwYXJzZTogcGFyc2VcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/borc/src/decoder.asm.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/borc/src/decoder.js":
/*!**********************************************!*\
  !*** ../../node_modules/borc/src/decoder.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"(ssr)/../../node_modules/ieee754/index.js\")\nconst Bignumber = (__webpack_require__(/*! bignumber.js */ \"(ssr)/../../node_modules/bignumber.js/bignumber.js\").BigNumber)\n\nconst parser = __webpack_require__(/*! ./decoder.asm */ \"(ssr)/../../node_modules/borc/src/decoder.asm.js\")\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/../../node_modules/borc/src/utils.js\")\nconst c = __webpack_require__(/*! ./constants */ \"(ssr)/../../node_modules/borc/src/constants.js\")\nconst Simple = __webpack_require__(/*! ./simple */ \"(ssr)/../../node_modules/borc/src/simple.js\")\nconst Tagged = __webpack_require__(/*! ./tagged */ \"(ssr)/../../node_modules/borc/src/tagged.js\")\nconst { URL } = __webpack_require__(/*! iso-url */ \"(ssr)/../../node_modules/iso-url/index.js\")\n\n/**\n * Transform binary cbor data into JavaScript objects.\n */\nclass Decoder {\n  /**\n   * @param {Object} [opts={}]\n   * @param {number} [opts.size=65536] - Size of the allocated heap.\n   */\n  constructor (opts) {\n    opts = opts || {}\n\n    if (!opts.size || opts.size < 0x10000) {\n      opts.size = 0x10000\n    } else {\n      // Ensure the size is a power of 2\n      opts.size = utils.nextPowerOf2(opts.size)\n    }\n\n    // Heap use to share the input with the parser\n    this._heap = new ArrayBuffer(opts.size)\n    this._heap8 = new Uint8Array(this._heap)\n    this._buffer = Buffer.from(this._heap)\n\n    this._reset()\n\n    // Known tags\n    this._knownTags = Object.assign({\n      0: (val) => new Date(val),\n      1: (val) => new Date(val * 1000),\n      2: (val) => utils.arrayBufferToBignumber(val),\n      3: (val) => c.NEG_ONE.minus(utils.arrayBufferToBignumber(val)),\n      4: (v) => {\n        // const v = new Uint8Array(val)\n        return c.TEN.pow(v[0]).times(v[1])\n      },\n      5: (v) => {\n        // const v = new Uint8Array(val)\n        return c.TWO.pow(v[0]).times(v[1])\n      },\n      32: (val) => new URL(val),\n      35: (val) => new RegExp(val)\n    }, opts.tags)\n\n    // Initialize asm based parser\n    this.parser = parser(global, {\n      // eslint-disable-next-line no-console\n      log: console.log.bind(console),\n      pushInt: this.pushInt.bind(this),\n      pushInt32: this.pushInt32.bind(this),\n      pushInt32Neg: this.pushInt32Neg.bind(this),\n      pushInt64: this.pushInt64.bind(this),\n      pushInt64Neg: this.pushInt64Neg.bind(this),\n      pushFloat: this.pushFloat.bind(this),\n      pushFloatSingle: this.pushFloatSingle.bind(this),\n      pushFloatDouble: this.pushFloatDouble.bind(this),\n      pushTrue: this.pushTrue.bind(this),\n      pushFalse: this.pushFalse.bind(this),\n      pushUndefined: this.pushUndefined.bind(this),\n      pushNull: this.pushNull.bind(this),\n      pushInfinity: this.pushInfinity.bind(this),\n      pushInfinityNeg: this.pushInfinityNeg.bind(this),\n      pushNaN: this.pushNaN.bind(this),\n      pushNaNNeg: this.pushNaNNeg.bind(this),\n      pushArrayStart: this.pushArrayStart.bind(this),\n      pushArrayStartFixed: this.pushArrayStartFixed.bind(this),\n      pushArrayStartFixed32: this.pushArrayStartFixed32.bind(this),\n      pushArrayStartFixed64: this.pushArrayStartFixed64.bind(this),\n      pushObjectStart: this.pushObjectStart.bind(this),\n      pushObjectStartFixed: this.pushObjectStartFixed.bind(this),\n      pushObjectStartFixed32: this.pushObjectStartFixed32.bind(this),\n      pushObjectStartFixed64: this.pushObjectStartFixed64.bind(this),\n      pushByteString: this.pushByteString.bind(this),\n      pushByteStringStart: this.pushByteStringStart.bind(this),\n      pushUtf8String: this.pushUtf8String.bind(this),\n      pushUtf8StringStart: this.pushUtf8StringStart.bind(this),\n      pushSimpleUnassigned: this.pushSimpleUnassigned.bind(this),\n      pushTagUnassigned: this.pushTagUnassigned.bind(this),\n      pushTagStart: this.pushTagStart.bind(this),\n      pushTagStart4: this.pushTagStart4.bind(this),\n      pushTagStart8: this.pushTagStart8.bind(this),\n      pushBreak: this.pushBreak.bind(this)\n    }, this._heap)\n  }\n\n  get _depth () {\n    return this._parents.length\n  }\n\n  get _currentParent () {\n    return this._parents[this._depth - 1]\n  }\n\n  get _ref () {\n    return this._currentParent.ref\n  }\n\n  // Finish the current parent\n  _closeParent () {\n    var p = this._parents.pop()\n\n    if (p.length > 0) {\n      throw new Error(`Missing ${p.length} elements`)\n    }\n\n    switch (p.type) {\n      case c.PARENT.TAG:\n        this._push(\n          this.createTag(p.ref[0], p.ref[1])\n        )\n        break\n      case c.PARENT.BYTE_STRING:\n        this._push(this.createByteString(p.ref, p.length))\n        break\n      case c.PARENT.UTF8_STRING:\n        this._push(this.createUtf8String(p.ref, p.length))\n        break\n      case c.PARENT.MAP:\n        if (p.values % 2 > 0) {\n          throw new Error('Odd number of elements in the map')\n        }\n        this._push(this.createMap(p.ref, p.length))\n        break\n      case c.PARENT.OBJECT:\n        if (p.values % 2 > 0) {\n          throw new Error('Odd number of elements in the map')\n        }\n        this._push(this.createObject(p.ref, p.length))\n        break\n      case c.PARENT.ARRAY:\n        this._push(this.createArray(p.ref, p.length))\n        break\n      default:\n        break\n    }\n\n    if (this._currentParent && this._currentParent.type === c.PARENT.TAG) {\n      this._dec()\n    }\n  }\n\n  // Reduce the expected length of the current parent by one\n  _dec () {\n    const p = this._currentParent\n    // The current parent does not know the epxected child length\n\n    if (p.length < 0) {\n      return\n    }\n\n    p.length--\n\n    // All children were seen, we can close the current parent\n    if (p.length === 0) {\n      this._closeParent()\n    }\n  }\n\n  // Push any value to the current parent\n  _push (val, hasChildren) {\n    const p = this._currentParent\n    p.values++\n\n    switch (p.type) {\n      case c.PARENT.ARRAY:\n      case c.PARENT.BYTE_STRING:\n      case c.PARENT.UTF8_STRING:\n        if (p.length > -1) {\n          this._ref[this._ref.length - p.length] = val\n        } else {\n          this._ref.push(val)\n        }\n        this._dec()\n        break\n      case c.PARENT.OBJECT:\n        if (p.tmpKey != null) {\n          this._ref[p.tmpKey] = val\n          p.tmpKey = null\n          this._dec()\n        } else {\n          p.tmpKey = val\n\n          if (typeof p.tmpKey !== 'string') {\n            // too bad, convert to a Map\n            p.type = c.PARENT.MAP\n            p.ref = utils.buildMap(p.ref)\n          }\n        }\n        break\n      case c.PARENT.MAP:\n        if (p.tmpKey != null) {\n          this._ref.set(p.tmpKey, val)\n          p.tmpKey = null\n          this._dec()\n        } else {\n          p.tmpKey = val\n        }\n        break\n      case c.PARENT.TAG:\n        this._ref.push(val)\n        if (!hasChildren) {\n          this._dec()\n        }\n        break\n      default:\n        throw new Error('Unknown parent type')\n    }\n  }\n\n  // Create a new parent in the parents list\n  _createParent (obj, type, len) {\n    this._parents[this._depth] = {\n      type: type,\n      length: len,\n      ref: obj,\n      values: 0,\n      tmpKey: null\n    }\n  }\n\n  // Reset all state back to the beginning, also used for initiatlization\n  _reset () {\n    this._res = []\n    this._parents = [{\n      type: c.PARENT.ARRAY,\n      length: -1,\n      ref: this._res,\n      values: 0,\n      tmpKey: null\n    }]\n  }\n\n  // -- Interface to customize deoding behaviour\n  createTag (tagNumber, value) {\n    const typ = this._knownTags[tagNumber]\n\n    if (!typ) {\n      return new Tagged(tagNumber, value)\n    }\n\n    return typ(value)\n  }\n\n  createMap (obj, len) {\n    return obj\n  }\n\n  createObject (obj, len) {\n    return obj\n  }\n\n  createArray (arr, len) {\n    return arr\n  }\n\n  createByteString (raw, len) {\n    return Buffer.concat(raw)\n  }\n\n  createByteStringFromHeap (start, end) {\n    if (start === end) {\n      return Buffer.alloc(0)\n    }\n\n    return Buffer.from(this._heap.slice(start, end))\n  }\n\n  createInt (val) {\n    return val\n  }\n\n  createInt32 (f, g) {\n    return utils.buildInt32(f, g)\n  }\n\n  createInt64 (f1, f2, g1, g2) {\n    return utils.buildInt64(f1, f2, g1, g2)\n  }\n\n  createFloat (val) {\n    return val\n  }\n\n  createFloatSingle (a, b, c, d) {\n    return ieee754.read([a, b, c, d], 0, false, 23, 4)\n  }\n\n  createFloatDouble (a, b, c, d, e, f, g, h) {\n    return ieee754.read([a, b, c, d, e, f, g, h], 0, false, 52, 8)\n  }\n\n  createInt32Neg (f, g) {\n    return -1 - utils.buildInt32(f, g)\n  }\n\n  createInt64Neg (f1, f2, g1, g2) {\n    const f = utils.buildInt32(f1, f2)\n    const g = utils.buildInt32(g1, g2)\n\n    if (f > c.MAX_SAFE_HIGH) {\n      return c.NEG_ONE.minus(new Bignumber(f).times(c.SHIFT32).plus(g))\n    }\n\n    return -1 - ((f * c.SHIFT32) + g)\n  }\n\n  createTrue () {\n    return true\n  }\n\n  createFalse () {\n    return false\n  }\n\n  createNull () {\n    return null\n  }\n\n  createUndefined () {\n    return undefined\n  }\n\n  createInfinity () {\n    return Infinity\n  }\n\n  createInfinityNeg () {\n    return -Infinity\n  }\n\n  createNaN () {\n    return NaN\n  }\n\n  createNaNNeg () {\n    return -NaN\n  }\n\n  createUtf8String (raw, len) {\n    return raw.join('')\n  }\n\n  createUtf8StringFromHeap (start, end) {\n    if (start === end) {\n      return ''\n    }\n\n    return this._buffer.toString('utf8', start, end)\n  }\n\n  createSimpleUnassigned (val) {\n    return new Simple(val)\n  }\n\n  // -- Interface for decoder.asm.js\n\n  pushInt (val) {\n    this._push(this.createInt(val))\n  }\n\n  pushInt32 (f, g) {\n    this._push(this.createInt32(f, g))\n  }\n\n  pushInt64 (f1, f2, g1, g2) {\n    this._push(this.createInt64(f1, f2, g1, g2))\n  }\n\n  pushFloat (val) {\n    this._push(this.createFloat(val))\n  }\n\n  pushFloatSingle (a, b, c, d) {\n    this._push(this.createFloatSingle(a, b, c, d))\n  }\n\n  pushFloatDouble (a, b, c, d, e, f, g, h) {\n    this._push(this.createFloatDouble(a, b, c, d, e, f, g, h))\n  }\n\n  pushInt32Neg (f, g) {\n    this._push(this.createInt32Neg(f, g))\n  }\n\n  pushInt64Neg (f1, f2, g1, g2) {\n    this._push(this.createInt64Neg(f1, f2, g1, g2))\n  }\n\n  pushTrue () {\n    this._push(this.createTrue())\n  }\n\n  pushFalse () {\n    this._push(this.createFalse())\n  }\n\n  pushNull () {\n    this._push(this.createNull())\n  }\n\n  pushUndefined () {\n    this._push(this.createUndefined())\n  }\n\n  pushInfinity () {\n    this._push(this.createInfinity())\n  }\n\n  pushInfinityNeg () {\n    this._push(this.createInfinityNeg())\n  }\n\n  pushNaN () {\n    this._push(this.createNaN())\n  }\n\n  pushNaNNeg () {\n    this._push(this.createNaNNeg())\n  }\n\n  pushArrayStart () {\n    this._createParent([], c.PARENT.ARRAY, -1)\n  }\n\n  pushArrayStartFixed (len) {\n    this._createArrayStartFixed(len)\n  }\n\n  pushArrayStartFixed32 (len1, len2) {\n    const len = utils.buildInt32(len1, len2)\n    this._createArrayStartFixed(len)\n  }\n\n  pushArrayStartFixed64 (len1, len2, len3, len4) {\n    const len = utils.buildInt64(len1, len2, len3, len4)\n    this._createArrayStartFixed(len)\n  }\n\n  pushObjectStart () {\n    this._createObjectStartFixed(-1)\n  }\n\n  pushObjectStartFixed (len) {\n    this._createObjectStartFixed(len)\n  }\n\n  pushObjectStartFixed32 (len1, len2) {\n    const len = utils.buildInt32(len1, len2)\n    this._createObjectStartFixed(len)\n  }\n\n  pushObjectStartFixed64 (len1, len2, len3, len4) {\n    const len = utils.buildInt64(len1, len2, len3, len4)\n    this._createObjectStartFixed(len)\n  }\n\n  pushByteStringStart () {\n    this._parents[this._depth] = {\n      type: c.PARENT.BYTE_STRING,\n      length: -1,\n      ref: [],\n      values: 0,\n      tmpKey: null\n    }\n  }\n\n  pushByteString (start, end) {\n    this._push(this.createByteStringFromHeap(start, end))\n  }\n\n  pushUtf8StringStart () {\n    this._parents[this._depth] = {\n      type: c.PARENT.UTF8_STRING,\n      length: -1,\n      ref: [],\n      values: 0,\n      tmpKey: null\n    }\n  }\n\n  pushUtf8String (start, end) {\n    this._push(this.createUtf8StringFromHeap(start, end))\n  }\n\n  pushSimpleUnassigned (val) {\n    this._push(this.createSimpleUnassigned(val))\n  }\n\n  pushTagStart (tag) {\n    this._parents[this._depth] = {\n      type: c.PARENT.TAG,\n      length: 1,\n      ref: [tag]\n    }\n  }\n\n  pushTagStart4 (f, g) {\n    this.pushTagStart(utils.buildInt32(f, g))\n  }\n\n  pushTagStart8 (f1, f2, g1, g2) {\n    this.pushTagStart(utils.buildInt64(f1, f2, g1, g2))\n  }\n\n  pushTagUnassigned (tagNumber) {\n    this._push(this.createTag(tagNumber))\n  }\n\n  pushBreak () {\n    if (this._currentParent.length > -1) {\n      throw new Error('Unexpected break')\n    }\n\n    this._closeParent()\n  }\n\n  _createObjectStartFixed (len) {\n    if (len === 0) {\n      this._push(this.createObject({}))\n      return\n    }\n\n    this._createParent({}, c.PARENT.OBJECT, len)\n  }\n\n  _createArrayStartFixed (len) {\n    if (len === 0) {\n      this._push(this.createArray([]))\n      return\n    }\n\n    this._createParent(new Array(len), c.PARENT.ARRAY, len)\n  }\n\n  _decode (input) {\n    if (input.byteLength === 0) {\n      throw new Error('Input too short')\n    }\n\n    this._reset()\n    this._heap8.set(input)\n    const code = this.parser.parse(input.byteLength)\n\n    if (this._depth > 1) {\n      while (this._currentParent.length === 0) {\n        this._closeParent()\n      }\n      if (this._depth > 1) {\n        throw new Error('Undeterminated nesting')\n      }\n    }\n\n    if (code > 0) {\n      throw new Error('Failed to parse')\n    }\n\n    if (this._res.length === 0) {\n      throw new Error('No valid result')\n    }\n  }\n\n  // -- Public Interface\n\n  decodeFirst (input) {\n    this._decode(input)\n\n    return this._res[0]\n  }\n\n  decodeAll (input) {\n    this._decode(input)\n\n    return this._res\n  }\n\n  /**\n   * Decode the first cbor object.\n   *\n   * @param {Buffer|string} input\n   * @param {string} [enc='hex'] - Encoding used if a string is passed.\n   * @returns {*}\n   */\n  static decode (input, enc) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, enc || 'hex')\n    }\n\n    const dec = new Decoder({ size: input.length })\n    return dec.decodeFirst(input)\n  }\n\n  /**\n   * Decode all cbor objects.\n   *\n   * @param {Buffer|string} input\n   * @param {string} [enc='hex'] - Encoding used if a string is passed.\n   * @returns {Array<*>}\n   */\n  static decodeAll (input, enc) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, enc || 'hex')\n    }\n\n    const dec = new Decoder({ size: input.length })\n    return dec.decodeAll(input)\n  }\n}\n\nDecoder.decodeFirst = Decoder.decode\n\nmodule.exports = Decoder\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2RlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQywwREFBUztBQUNqQyxrQkFBa0IseUdBQWlDOztBQUVuRCxlQUFlLG1CQUFPLENBQUMsdUVBQWU7QUFDdEMsY0FBYyxtQkFBTyxDQUFDLDJEQUFTO0FBQy9CLFVBQVUsbUJBQU8sQ0FBQyxtRUFBYTtBQUMvQixlQUFlLG1CQUFPLENBQUMsNkRBQVU7QUFDakMsZUFBZSxtQkFBTyxDQUFDLDZEQUFVO0FBQ2pDLFFBQVEsTUFBTSxFQUFFLG1CQUFPLENBQUMsMERBQVM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVEsUUFBUTtBQUM3QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsVUFBVTtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLG9CQUFvQjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLG9CQUFvQjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ub2JvZHkxL1dvcmsvcTN4L3NjYWZmb2xkLWljcC9ub2RlX21vZHVsZXMvYm9yYy9zcmMvZGVjb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5jb25zdCBCaWdudW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKS5CaWdOdW1iZXJcblxuY29uc3QgcGFyc2VyID0gcmVxdWlyZSgnLi9kZWNvZGVyLmFzbScpXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgYyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IFNpbXBsZSA9IHJlcXVpcmUoJy4vc2ltcGxlJylcbmNvbnN0IFRhZ2dlZCA9IHJlcXVpcmUoJy4vdGFnZ2VkJylcbmNvbnN0IHsgVVJMIH0gPSByZXF1aXJlKCdpc28tdXJsJylcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYmluYXJ5IGNib3IgZGF0YSBpbnRvIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuY2xhc3MgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHM9e31dXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5zaXplPTY1NTM2XSAtIFNpemUgb2YgdGhlIGFsbG9jYXRlZCBoZWFwLlxuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgaWYgKCFvcHRzLnNpemUgfHwgb3B0cy5zaXplIDwgMHgxMDAwMCkge1xuICAgICAgb3B0cy5zaXplID0gMHgxMDAwMFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbnN1cmUgdGhlIHNpemUgaXMgYSBwb3dlciBvZiAyXG4gICAgICBvcHRzLnNpemUgPSB1dGlscy5uZXh0UG93ZXJPZjIob3B0cy5zaXplKVxuICAgIH1cblxuICAgIC8vIEhlYXAgdXNlIHRvIHNoYXJlIHRoZSBpbnB1dCB3aXRoIHRoZSBwYXJzZXJcbiAgICB0aGlzLl9oZWFwID0gbmV3IEFycmF5QnVmZmVyKG9wdHMuc2l6ZSlcbiAgICB0aGlzLl9oZWFwOCA9IG5ldyBVaW50OEFycmF5KHRoaXMuX2hlYXApXG4gICAgdGhpcy5fYnVmZmVyID0gQnVmZmVyLmZyb20odGhpcy5faGVhcClcblxuICAgIHRoaXMuX3Jlc2V0KClcblxuICAgIC8vIEtub3duIHRhZ3NcbiAgICB0aGlzLl9rbm93blRhZ3MgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIDA6ICh2YWwpID0+IG5ldyBEYXRlKHZhbCksXG4gICAgICAxOiAodmFsKSA9PiBuZXcgRGF0ZSh2YWwgKiAxMDAwKSxcbiAgICAgIDI6ICh2YWwpID0+IHV0aWxzLmFycmF5QnVmZmVyVG9CaWdudW1iZXIodmFsKSxcbiAgICAgIDM6ICh2YWwpID0+IGMuTkVHX09ORS5taW51cyh1dGlscy5hcnJheUJ1ZmZlclRvQmlnbnVtYmVyKHZhbCkpLFxuICAgICAgNDogKHYpID0+IHtcbiAgICAgICAgLy8gY29uc3QgdiA9IG5ldyBVaW50OEFycmF5KHZhbClcbiAgICAgICAgcmV0dXJuIGMuVEVOLnBvdyh2WzBdKS50aW1lcyh2WzFdKVxuICAgICAgfSxcbiAgICAgIDU6ICh2KSA9PiB7XG4gICAgICAgIC8vIGNvbnN0IHYgPSBuZXcgVWludDhBcnJheSh2YWwpXG4gICAgICAgIHJldHVybiBjLlRXTy5wb3codlswXSkudGltZXModlsxXSlcbiAgICAgIH0sXG4gICAgICAzMjogKHZhbCkgPT4gbmV3IFVSTCh2YWwpLFxuICAgICAgMzU6ICh2YWwpID0+IG5ldyBSZWdFeHAodmFsKVxuICAgIH0sIG9wdHMudGFncylcblxuICAgIC8vIEluaXRpYWxpemUgYXNtIGJhc2VkIHBhcnNlclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyKGdsb2JhbCwge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGxvZzogY29uc29sZS5sb2cuYmluZChjb25zb2xlKSxcbiAgICAgIHB1c2hJbnQ6IHRoaXMucHVzaEludC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEludDMyOiB0aGlzLnB1c2hJbnQzMi5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEludDMyTmVnOiB0aGlzLnB1c2hJbnQzMk5lZy5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEludDY0OiB0aGlzLnB1c2hJbnQ2NC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEludDY0TmVnOiB0aGlzLnB1c2hJbnQ2NE5lZy5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEZsb2F0OiB0aGlzLnB1c2hGbG9hdC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEZsb2F0U2luZ2xlOiB0aGlzLnB1c2hGbG9hdFNpbmdsZS5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEZsb2F0RG91YmxlOiB0aGlzLnB1c2hGbG9hdERvdWJsZS5iaW5kKHRoaXMpLFxuICAgICAgcHVzaFRydWU6IHRoaXMucHVzaFRydWUuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hGYWxzZTogdGhpcy5wdXNoRmFsc2UuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hVbmRlZmluZWQ6IHRoaXMucHVzaFVuZGVmaW5lZC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaE51bGw6IHRoaXMucHVzaE51bGwuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hJbmZpbml0eTogdGhpcy5wdXNoSW5maW5pdHkuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hJbmZpbml0eU5lZzogdGhpcy5wdXNoSW5maW5pdHlOZWcuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hOYU46IHRoaXMucHVzaE5hTi5iaW5kKHRoaXMpLFxuICAgICAgcHVzaE5hTk5lZzogdGhpcy5wdXNoTmFOTmVnLmJpbmQodGhpcyksXG4gICAgICBwdXNoQXJyYXlTdGFydDogdGhpcy5wdXNoQXJyYXlTdGFydC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEFycmF5U3RhcnRGaXhlZDogdGhpcy5wdXNoQXJyYXlTdGFydEZpeGVkLmJpbmQodGhpcyksXG4gICAgICBwdXNoQXJyYXlTdGFydEZpeGVkMzI6IHRoaXMucHVzaEFycmF5U3RhcnRGaXhlZDMyLmJpbmQodGhpcyksXG4gICAgICBwdXNoQXJyYXlTdGFydEZpeGVkNjQ6IHRoaXMucHVzaEFycmF5U3RhcnRGaXhlZDY0LmJpbmQodGhpcyksXG4gICAgICBwdXNoT2JqZWN0U3RhcnQ6IHRoaXMucHVzaE9iamVjdFN0YXJ0LmJpbmQodGhpcyksXG4gICAgICBwdXNoT2JqZWN0U3RhcnRGaXhlZDogdGhpcy5wdXNoT2JqZWN0U3RhcnRGaXhlZC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaE9iamVjdFN0YXJ0Rml4ZWQzMjogdGhpcy5wdXNoT2JqZWN0U3RhcnRGaXhlZDMyLmJpbmQodGhpcyksXG4gICAgICBwdXNoT2JqZWN0U3RhcnRGaXhlZDY0OiB0aGlzLnB1c2hPYmplY3RTdGFydEZpeGVkNjQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hCeXRlU3RyaW5nOiB0aGlzLnB1c2hCeXRlU3RyaW5nLmJpbmQodGhpcyksXG4gICAgICBwdXNoQnl0ZVN0cmluZ1N0YXJ0OiB0aGlzLnB1c2hCeXRlU3RyaW5nU3RhcnQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hVdGY4U3RyaW5nOiB0aGlzLnB1c2hVdGY4U3RyaW5nLmJpbmQodGhpcyksXG4gICAgICBwdXNoVXRmOFN0cmluZ1N0YXJ0OiB0aGlzLnB1c2hVdGY4U3RyaW5nU3RhcnQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hTaW1wbGVVbmFzc2lnbmVkOiB0aGlzLnB1c2hTaW1wbGVVbmFzc2lnbmVkLmJpbmQodGhpcyksXG4gICAgICBwdXNoVGFnVW5hc3NpZ25lZDogdGhpcy5wdXNoVGFnVW5hc3NpZ25lZC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaFRhZ1N0YXJ0OiB0aGlzLnB1c2hUYWdTdGFydC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaFRhZ1N0YXJ0NDogdGhpcy5wdXNoVGFnU3RhcnQ0LmJpbmQodGhpcyksXG4gICAgICBwdXNoVGFnU3RhcnQ4OiB0aGlzLnB1c2hUYWdTdGFydDguYmluZCh0aGlzKSxcbiAgICAgIHB1c2hCcmVhazogdGhpcy5wdXNoQnJlYWsuYmluZCh0aGlzKVxuICAgIH0sIHRoaXMuX2hlYXApXG4gIH1cblxuICBnZXQgX2RlcHRoICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50cy5sZW5ndGhcbiAgfVxuXG4gIGdldCBfY3VycmVudFBhcmVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudHNbdGhpcy5fZGVwdGggLSAxXVxuICB9XG5cbiAgZ2V0IF9yZWYgKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50UGFyZW50LnJlZlxuICB9XG5cbiAgLy8gRmluaXNoIHRoZSBjdXJyZW50IHBhcmVudFxuICBfY2xvc2VQYXJlbnQgKCkge1xuICAgIHZhciBwID0gdGhpcy5fcGFyZW50cy5wb3AoKVxuXG4gICAgaWYgKHAubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nICR7cC5sZW5ndGh9IGVsZW1lbnRzYClcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHAudHlwZSkge1xuICAgICAgY2FzZSBjLlBBUkVOVC5UQUc6XG4gICAgICAgIHRoaXMuX3B1c2goXG4gICAgICAgICAgdGhpcy5jcmVhdGVUYWcocC5yZWZbMF0sIHAucmVmWzFdKVxuICAgICAgICApXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIGMuUEFSRU5ULkJZVEVfU1RSSU5HOlxuICAgICAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlQnl0ZVN0cmluZyhwLnJlZiwgcC5sZW5ndGgpKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBjLlBBUkVOVC5VVEY4X1NUUklORzpcbiAgICAgICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZVV0ZjhTdHJpbmcocC5yZWYsIHAubGVuZ3RoKSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgYy5QQVJFTlQuTUFQOlxuICAgICAgICBpZiAocC52YWx1ZXMgJSAyID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2RkIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgbWFwJylcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlTWFwKHAucmVmLCBwLmxlbmd0aCkpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIGMuUEFSRU5ULk9CSkVDVDpcbiAgICAgICAgaWYgKHAudmFsdWVzICUgMiA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09kZCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIG1hcCcpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZU9iamVjdChwLnJlZiwgcC5sZW5ndGgpKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBjLlBBUkVOVC5BUlJBWTpcbiAgICAgICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZUFycmF5KHAucmVmLCBwLmxlbmd0aCkpXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jdXJyZW50UGFyZW50ICYmIHRoaXMuX2N1cnJlbnRQYXJlbnQudHlwZSA9PT0gYy5QQVJFTlQuVEFHKSB7XG4gICAgICB0aGlzLl9kZWMoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlZHVjZSB0aGUgZXhwZWN0ZWQgbGVuZ3RoIG9mIHRoZSBjdXJyZW50IHBhcmVudCBieSBvbmVcbiAgX2RlYyAoKSB7XG4gICAgY29uc3QgcCA9IHRoaXMuX2N1cnJlbnRQYXJlbnRcbiAgICAvLyBUaGUgY3VycmVudCBwYXJlbnQgZG9lcyBub3Qga25vdyB0aGUgZXB4ZWN0ZWQgY2hpbGQgbGVuZ3RoXG5cbiAgICBpZiAocC5sZW5ndGggPCAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBwLmxlbmd0aC0tXG5cbiAgICAvLyBBbGwgY2hpbGRyZW4gd2VyZSBzZWVuLCB3ZSBjYW4gY2xvc2UgdGhlIGN1cnJlbnQgcGFyZW50XG4gICAgaWYgKHAubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9jbG9zZVBhcmVudCgpXG4gICAgfVxuICB9XG5cbiAgLy8gUHVzaCBhbnkgdmFsdWUgdG8gdGhlIGN1cnJlbnQgcGFyZW50XG4gIF9wdXNoICh2YWwsIGhhc0NoaWxkcmVuKSB7XG4gICAgY29uc3QgcCA9IHRoaXMuX2N1cnJlbnRQYXJlbnRcbiAgICBwLnZhbHVlcysrXG5cbiAgICBzd2l0Y2ggKHAudHlwZSkge1xuICAgICAgY2FzZSBjLlBBUkVOVC5BUlJBWTpcbiAgICAgIGNhc2UgYy5QQVJFTlQuQllURV9TVFJJTkc6XG4gICAgICBjYXNlIGMuUEFSRU5ULlVURjhfU1RSSU5HOlxuICAgICAgICBpZiAocC5sZW5ndGggPiAtMSkge1xuICAgICAgICAgIHRoaXMuX3JlZlt0aGlzLl9yZWYubGVuZ3RoIC0gcC5sZW5ndGhdID0gdmFsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcmVmLnB1c2godmFsKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlYygpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIGMuUEFSRU5ULk9CSkVDVDpcbiAgICAgICAgaWYgKHAudG1wS2V5ICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl9yZWZbcC50bXBLZXldID0gdmFsXG4gICAgICAgICAgcC50bXBLZXkgPSBudWxsXG4gICAgICAgICAgdGhpcy5fZGVjKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwLnRtcEtleSA9IHZhbFxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBwLnRtcEtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIHRvbyBiYWQsIGNvbnZlcnQgdG8gYSBNYXBcbiAgICAgICAgICAgIHAudHlwZSA9IGMuUEFSRU5ULk1BUFxuICAgICAgICAgICAgcC5yZWYgPSB1dGlscy5idWlsZE1hcChwLnJlZilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgYy5QQVJFTlQuTUFQOlxuICAgICAgICBpZiAocC50bXBLZXkgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX3JlZi5zZXQocC50bXBLZXksIHZhbClcbiAgICAgICAgICBwLnRtcEtleSA9IG51bGxcbiAgICAgICAgICB0aGlzLl9kZWMoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHAudG1wS2V5ID0gdmFsXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgYy5QQVJFTlQuVEFHOlxuICAgICAgICB0aGlzLl9yZWYucHVzaCh2YWwpXG4gICAgICAgIGlmICghaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgICB0aGlzLl9kZWMoKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcGFyZW50IHR5cGUnKVxuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSBhIG5ldyBwYXJlbnQgaW4gdGhlIHBhcmVudHMgbGlzdFxuICBfY3JlYXRlUGFyZW50IChvYmosIHR5cGUsIGxlbikge1xuICAgIHRoaXMuX3BhcmVudHNbdGhpcy5fZGVwdGhdID0ge1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGxlbmd0aDogbGVuLFxuICAgICAgcmVmOiBvYmosXG4gICAgICB2YWx1ZXM6IDAsXG4gICAgICB0bXBLZXk6IG51bGxcbiAgICB9XG4gIH1cblxuICAvLyBSZXNldCBhbGwgc3RhdGUgYmFjayB0byB0aGUgYmVnaW5uaW5nLCBhbHNvIHVzZWQgZm9yIGluaXRpYXRsaXphdGlvblxuICBfcmVzZXQgKCkge1xuICAgIHRoaXMuX3JlcyA9IFtdXG4gICAgdGhpcy5fcGFyZW50cyA9IFt7XG4gICAgICB0eXBlOiBjLlBBUkVOVC5BUlJBWSxcbiAgICAgIGxlbmd0aDogLTEsXG4gICAgICByZWY6IHRoaXMuX3JlcyxcbiAgICAgIHZhbHVlczogMCxcbiAgICAgIHRtcEtleTogbnVsbFxuICAgIH1dXG4gIH1cblxuICAvLyAtLSBJbnRlcmZhY2UgdG8gY3VzdG9taXplIGRlb2RpbmcgYmVoYXZpb3VyXG4gIGNyZWF0ZVRhZyAodGFnTnVtYmVyLCB2YWx1ZSkge1xuICAgIGNvbnN0IHR5cCA9IHRoaXMuX2tub3duVGFnc1t0YWdOdW1iZXJdXG5cbiAgICBpZiAoIXR5cCkge1xuICAgICAgcmV0dXJuIG5ldyBUYWdnZWQodGFnTnVtYmVyLCB2YWx1ZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwKHZhbHVlKVxuICB9XG5cbiAgY3JlYXRlTWFwIChvYmosIGxlbikge1xuICAgIHJldHVybiBvYmpcbiAgfVxuXG4gIGNyZWF0ZU9iamVjdCAob2JqLCBsZW4pIHtcbiAgICByZXR1cm4gb2JqXG4gIH1cblxuICBjcmVhdGVBcnJheSAoYXJyLCBsZW4pIHtcbiAgICByZXR1cm4gYXJyXG4gIH1cblxuICBjcmVhdGVCeXRlU3RyaW5nIChyYXcsIGxlbikge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KHJhdylcbiAgfVxuXG4gIGNyZWF0ZUJ5dGVTdHJpbmdGcm9tSGVhcCAoc3RhcnQsIGVuZCkge1xuICAgIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gICAgfVxuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMuX2hlYXAuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cblxuICBjcmVhdGVJbnQgKHZhbCkge1xuICAgIHJldHVybiB2YWxcbiAgfVxuXG4gIGNyZWF0ZUludDMyIChmLCBnKSB7XG4gICAgcmV0dXJuIHV0aWxzLmJ1aWxkSW50MzIoZiwgZylcbiAgfVxuXG4gIGNyZWF0ZUludDY0IChmMSwgZjIsIGcxLCBnMikge1xuICAgIHJldHVybiB1dGlscy5idWlsZEludDY0KGYxLCBmMiwgZzEsIGcyKVxuICB9XG5cbiAgY3JlYXRlRmxvYXQgKHZhbCkge1xuICAgIHJldHVybiB2YWxcbiAgfVxuXG4gIGNyZWF0ZUZsb2F0U2luZ2xlIChhLCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGllZWU3NTQucmVhZChbYSwgYiwgYywgZF0sIDAsIGZhbHNlLCAyMywgNClcbiAgfVxuXG4gIGNyZWF0ZUZsb2F0RG91YmxlIChhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKSB7XG4gICAgcmV0dXJuIGllZWU3NTQucmVhZChbYSwgYiwgYywgZCwgZSwgZiwgZywgaF0sIDAsIGZhbHNlLCA1MiwgOClcbiAgfVxuXG4gIGNyZWF0ZUludDMyTmVnIChmLCBnKSB7XG4gICAgcmV0dXJuIC0xIC0gdXRpbHMuYnVpbGRJbnQzMihmLCBnKVxuICB9XG5cbiAgY3JlYXRlSW50NjROZWcgKGYxLCBmMiwgZzEsIGcyKSB7XG4gICAgY29uc3QgZiA9IHV0aWxzLmJ1aWxkSW50MzIoZjEsIGYyKVxuICAgIGNvbnN0IGcgPSB1dGlscy5idWlsZEludDMyKGcxLCBnMilcblxuICAgIGlmIChmID4gYy5NQVhfU0FGRV9ISUdIKSB7XG4gICAgICByZXR1cm4gYy5ORUdfT05FLm1pbnVzKG5ldyBCaWdudW1iZXIoZikudGltZXMoYy5TSElGVDMyKS5wbHVzKGcpKVxuICAgIH1cblxuICAgIHJldHVybiAtMSAtICgoZiAqIGMuU0hJRlQzMikgKyBnKVxuICB9XG5cbiAgY3JlYXRlVHJ1ZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNyZWF0ZUZhbHNlICgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNyZWF0ZU51bGwgKCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjcmVhdGVVbmRlZmluZWQgKCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGNyZWF0ZUluZmluaXR5ICgpIHtcbiAgICByZXR1cm4gSW5maW5pdHlcbiAgfVxuXG4gIGNyZWF0ZUluZmluaXR5TmVnICgpIHtcbiAgICByZXR1cm4gLUluZmluaXR5XG4gIH1cblxuICBjcmVhdGVOYU4gKCkge1xuICAgIHJldHVybiBOYU5cbiAgfVxuXG4gIGNyZWF0ZU5hTk5lZyAoKSB7XG4gICAgcmV0dXJuIC1OYU5cbiAgfVxuXG4gIGNyZWF0ZVV0ZjhTdHJpbmcgKHJhdywgbGVuKSB7XG4gICAgcmV0dXJuIHJhdy5qb2luKCcnKVxuICB9XG5cbiAgY3JlYXRlVXRmOFN0cmluZ0Zyb21IZWFwIChzdGFydCwgZW5kKSB7XG4gICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9idWZmZXIudG9TdHJpbmcoJ3V0ZjgnLCBzdGFydCwgZW5kKVxuICB9XG5cbiAgY3JlYXRlU2ltcGxlVW5hc3NpZ25lZCAodmFsKSB7XG4gICAgcmV0dXJuIG5ldyBTaW1wbGUodmFsKVxuICB9XG5cbiAgLy8gLS0gSW50ZXJmYWNlIGZvciBkZWNvZGVyLmFzbS5qc1xuXG4gIHB1c2hJbnQgKHZhbCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVJbnQodmFsKSlcbiAgfVxuXG4gIHB1c2hJbnQzMiAoZiwgZykge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVJbnQzMihmLCBnKSlcbiAgfVxuXG4gIHB1c2hJbnQ2NCAoZjEsIGYyLCBnMSwgZzIpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlSW50NjQoZjEsIGYyLCBnMSwgZzIpKVxuICB9XG5cbiAgcHVzaEZsb2F0ICh2YWwpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlRmxvYXQodmFsKSlcbiAgfVxuXG4gIHB1c2hGbG9hdFNpbmdsZSAoYSwgYiwgYywgZCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVGbG9hdFNpbmdsZShhLCBiLCBjLCBkKSlcbiAgfVxuXG4gIHB1c2hGbG9hdERvdWJsZSAoYSwgYiwgYywgZCwgZSwgZiwgZywgaCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVGbG9hdERvdWJsZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKSlcbiAgfVxuXG4gIHB1c2hJbnQzMk5lZyAoZiwgZykge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVJbnQzMk5lZyhmLCBnKSlcbiAgfVxuXG4gIHB1c2hJbnQ2NE5lZyAoZjEsIGYyLCBnMSwgZzIpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlSW50NjROZWcoZjEsIGYyLCBnMSwgZzIpKVxuICB9XG5cbiAgcHVzaFRydWUgKCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVUcnVlKCkpXG4gIH1cblxuICBwdXNoRmFsc2UgKCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVGYWxzZSgpKVxuICB9XG5cbiAgcHVzaE51bGwgKCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVOdWxsKCkpXG4gIH1cblxuICBwdXNoVW5kZWZpbmVkICgpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlVW5kZWZpbmVkKCkpXG4gIH1cblxuICBwdXNoSW5maW5pdHkgKCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVJbmZpbml0eSgpKVxuICB9XG5cbiAgcHVzaEluZmluaXR5TmVnICgpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlSW5maW5pdHlOZWcoKSlcbiAgfVxuXG4gIHB1c2hOYU4gKCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVOYU4oKSlcbiAgfVxuXG4gIHB1c2hOYU5OZWcgKCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVOYU5OZWcoKSlcbiAgfVxuXG4gIHB1c2hBcnJheVN0YXJ0ICgpIHtcbiAgICB0aGlzLl9jcmVhdGVQYXJlbnQoW10sIGMuUEFSRU5ULkFSUkFZLCAtMSlcbiAgfVxuXG4gIHB1c2hBcnJheVN0YXJ0Rml4ZWQgKGxlbikge1xuICAgIHRoaXMuX2NyZWF0ZUFycmF5U3RhcnRGaXhlZChsZW4pXG4gIH1cblxuICBwdXNoQXJyYXlTdGFydEZpeGVkMzIgKGxlbjEsIGxlbjIpIHtcbiAgICBjb25zdCBsZW4gPSB1dGlscy5idWlsZEludDMyKGxlbjEsIGxlbjIpXG4gICAgdGhpcy5fY3JlYXRlQXJyYXlTdGFydEZpeGVkKGxlbilcbiAgfVxuXG4gIHB1c2hBcnJheVN0YXJ0Rml4ZWQ2NCAobGVuMSwgbGVuMiwgbGVuMywgbGVuNCkge1xuICAgIGNvbnN0IGxlbiA9IHV0aWxzLmJ1aWxkSW50NjQobGVuMSwgbGVuMiwgbGVuMywgbGVuNClcbiAgICB0aGlzLl9jcmVhdGVBcnJheVN0YXJ0Rml4ZWQobGVuKVxuICB9XG5cbiAgcHVzaE9iamVjdFN0YXJ0ICgpIHtcbiAgICB0aGlzLl9jcmVhdGVPYmplY3RTdGFydEZpeGVkKC0xKVxuICB9XG5cbiAgcHVzaE9iamVjdFN0YXJ0Rml4ZWQgKGxlbikge1xuICAgIHRoaXMuX2NyZWF0ZU9iamVjdFN0YXJ0Rml4ZWQobGVuKVxuICB9XG5cbiAgcHVzaE9iamVjdFN0YXJ0Rml4ZWQzMiAobGVuMSwgbGVuMikge1xuICAgIGNvbnN0IGxlbiA9IHV0aWxzLmJ1aWxkSW50MzIobGVuMSwgbGVuMilcbiAgICB0aGlzLl9jcmVhdGVPYmplY3RTdGFydEZpeGVkKGxlbilcbiAgfVxuXG4gIHB1c2hPYmplY3RTdGFydEZpeGVkNjQgKGxlbjEsIGxlbjIsIGxlbjMsIGxlbjQpIHtcbiAgICBjb25zdCBsZW4gPSB1dGlscy5idWlsZEludDY0KGxlbjEsIGxlbjIsIGxlbjMsIGxlbjQpXG4gICAgdGhpcy5fY3JlYXRlT2JqZWN0U3RhcnRGaXhlZChsZW4pXG4gIH1cblxuICBwdXNoQnl0ZVN0cmluZ1N0YXJ0ICgpIHtcbiAgICB0aGlzLl9wYXJlbnRzW3RoaXMuX2RlcHRoXSA9IHtcbiAgICAgIHR5cGU6IGMuUEFSRU5ULkJZVEVfU1RSSU5HLFxuICAgICAgbGVuZ3RoOiAtMSxcbiAgICAgIHJlZjogW10sXG4gICAgICB2YWx1ZXM6IDAsXG4gICAgICB0bXBLZXk6IG51bGxcbiAgICB9XG4gIH1cblxuICBwdXNoQnl0ZVN0cmluZyAoc3RhcnQsIGVuZCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVCeXRlU3RyaW5nRnJvbUhlYXAoc3RhcnQsIGVuZCkpXG4gIH1cblxuICBwdXNoVXRmOFN0cmluZ1N0YXJ0ICgpIHtcbiAgICB0aGlzLl9wYXJlbnRzW3RoaXMuX2RlcHRoXSA9IHtcbiAgICAgIHR5cGU6IGMuUEFSRU5ULlVURjhfU1RSSU5HLFxuICAgICAgbGVuZ3RoOiAtMSxcbiAgICAgIHJlZjogW10sXG4gICAgICB2YWx1ZXM6IDAsXG4gICAgICB0bXBLZXk6IG51bGxcbiAgICB9XG4gIH1cblxuICBwdXNoVXRmOFN0cmluZyAoc3RhcnQsIGVuZCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVVdGY4U3RyaW5nRnJvbUhlYXAoc3RhcnQsIGVuZCkpXG4gIH1cblxuICBwdXNoU2ltcGxlVW5hc3NpZ25lZCAodmFsKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZVNpbXBsZVVuYXNzaWduZWQodmFsKSlcbiAgfVxuXG4gIHB1c2hUYWdTdGFydCAodGFnKSB7XG4gICAgdGhpcy5fcGFyZW50c1t0aGlzLl9kZXB0aF0gPSB7XG4gICAgICB0eXBlOiBjLlBBUkVOVC5UQUcsXG4gICAgICBsZW5ndGg6IDEsXG4gICAgICByZWY6IFt0YWddXG4gICAgfVxuICB9XG5cbiAgcHVzaFRhZ1N0YXJ0NCAoZiwgZykge1xuICAgIHRoaXMucHVzaFRhZ1N0YXJ0KHV0aWxzLmJ1aWxkSW50MzIoZiwgZykpXG4gIH1cblxuICBwdXNoVGFnU3RhcnQ4IChmMSwgZjIsIGcxLCBnMikge1xuICAgIHRoaXMucHVzaFRhZ1N0YXJ0KHV0aWxzLmJ1aWxkSW50NjQoZjEsIGYyLCBnMSwgZzIpKVxuICB9XG5cbiAgcHVzaFRhZ1VuYXNzaWduZWQgKHRhZ051bWJlcikge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVUYWcodGFnTnVtYmVyKSlcbiAgfVxuXG4gIHB1c2hCcmVhayAoKSB7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRQYXJlbnQubGVuZ3RoID4gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBicmVhaycpXG4gICAgfVxuXG4gICAgdGhpcy5fY2xvc2VQYXJlbnQoKVxuICB9XG5cbiAgX2NyZWF0ZU9iamVjdFN0YXJ0Rml4ZWQgKGxlbikge1xuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVPYmplY3Qoe30pKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fY3JlYXRlUGFyZW50KHt9LCBjLlBBUkVOVC5PQkpFQ1QsIGxlbilcbiAgfVxuXG4gIF9jcmVhdGVBcnJheVN0YXJ0Rml4ZWQgKGxlbikge1xuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVBcnJheShbXSkpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9jcmVhdGVQYXJlbnQobmV3IEFycmF5KGxlbiksIGMuUEFSRU5ULkFSUkFZLCBsZW4pXG4gIH1cblxuICBfZGVjb2RlIChpbnB1dCkge1xuICAgIGlmIChpbnB1dC5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHRvbyBzaG9ydCcpXG4gICAgfVxuXG4gICAgdGhpcy5fcmVzZXQoKVxuICAgIHRoaXMuX2hlYXA4LnNldChpbnB1dClcbiAgICBjb25zdCBjb2RlID0gdGhpcy5wYXJzZXIucGFyc2UoaW5wdXQuYnl0ZUxlbmd0aClcblxuICAgIGlmICh0aGlzLl9kZXB0aCA+IDEpIHtcbiAgICAgIHdoaWxlICh0aGlzLl9jdXJyZW50UGFyZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9jbG9zZVBhcmVudCgpXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fZGVwdGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5kZXRlcm1pbmF0ZWQgbmVzdGluZycpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZScpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3Jlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsaWQgcmVzdWx0JylcbiAgICB9XG4gIH1cblxuICAvLyAtLSBQdWJsaWMgSW50ZXJmYWNlXG5cbiAgZGVjb2RlRmlyc3QgKGlucHV0KSB7XG4gICAgdGhpcy5fZGVjb2RlKGlucHV0KVxuXG4gICAgcmV0dXJuIHRoaXMuX3Jlc1swXVxuICB9XG5cbiAgZGVjb2RlQWxsIChpbnB1dCkge1xuICAgIHRoaXMuX2RlY29kZShpbnB1dClcblxuICAgIHJldHVybiB0aGlzLl9yZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgdGhlIGZpcnN0IGNib3Igb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcnxzdHJpbmd9IGlucHV0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jPSdoZXgnXSAtIEVuY29kaW5nIHVzZWQgaWYgYSBzdHJpbmcgaXMgcGFzc2VkLlxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHN0YXRpYyBkZWNvZGUgKGlucHV0LCBlbmMpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgaW5wdXQgPSBCdWZmZXIuZnJvbShpbnB1dCwgZW5jIHx8ICdoZXgnKVxuICAgIH1cblxuICAgIGNvbnN0IGRlYyA9IG5ldyBEZWNvZGVyKHsgc2l6ZTogaW5wdXQubGVuZ3RoIH0pXG4gICAgcmV0dXJuIGRlYy5kZWNvZGVGaXJzdChpbnB1dClcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYWxsIGNib3Igb2JqZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfSBpbnB1dFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2VuYz0naGV4J10gLSBFbmNvZGluZyB1c2VkIGlmIGEgc3RyaW5nIGlzIHBhc3NlZC5cbiAgICogQHJldHVybnMge0FycmF5PCo+fVxuICAgKi9cbiAgc3RhdGljIGRlY29kZUFsbCAoaW5wdXQsIGVuYykge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpbnB1dCA9IEJ1ZmZlci5mcm9tKGlucHV0LCBlbmMgfHwgJ2hleCcpXG4gICAgfVxuXG4gICAgY29uc3QgZGVjID0gbmV3IERlY29kZXIoeyBzaXplOiBpbnB1dC5sZW5ndGggfSlcbiAgICByZXR1cm4gZGVjLmRlY29kZUFsbChpbnB1dClcbiAgfVxufVxuXG5EZWNvZGVyLmRlY29kZUZpcnN0ID0gRGVjb2Rlci5kZWNvZGVcblxubW9kdWxlLmV4cG9ydHMgPSBEZWNvZGVyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/borc/src/decoder.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/borc/src/diagnose.js":
/*!***********************************************!*\
  !*** ../../node_modules/borc/src/diagnose.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\")\nconst Decoder = __webpack_require__(/*! ./decoder */ \"(ssr)/../../node_modules/borc/src/decoder.js\")\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/../../node_modules/borc/src/utils.js\")\n\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n */\nclass Diagnose extends Decoder {\n  createTag (tagNumber, value) {\n    return `${tagNumber}(${value})`\n  }\n\n  createInt (val) {\n    return super.createInt(val).toString()\n  }\n\n  createInt32 (f, g) {\n    return super.createInt32(f, g).toString()\n  }\n\n  createInt64 (f1, f2, g1, g2) {\n    return super.createInt64(f1, f2, g1, g2).toString()\n  }\n\n  createInt32Neg (f, g) {\n    return super.createInt32Neg(f, g).toString()\n  }\n\n  createInt64Neg (f1, f2, g1, g2) {\n    return super.createInt64Neg(f1, f2, g1, g2).toString()\n  }\n\n  createTrue () {\n    return 'true'\n  }\n\n  createFalse () {\n    return 'false'\n  }\n\n  createFloat (val) {\n    const fl = super.createFloat(val)\n    if (utils.isNegativeZero(val)) {\n      return '-0_1'\n    }\n\n    return `${fl}_1`\n  }\n\n  createFloatSingle (a, b, c, d) {\n    const fl = super.createFloatSingle(a, b, c, d)\n    return `${fl}_2`\n  }\n\n  createFloatDouble (a, b, c, d, e, f, g, h) {\n    const fl = super.createFloatDouble(a, b, c, d, e, f, g, h)\n    return `${fl}_3`\n  }\n\n  createByteString (raw, len) {\n    const val = raw.join(', ')\n\n    if (len === -1) {\n      return `(_ ${val})`\n    }\n    return `h'${val}`\n  }\n\n  createByteStringFromHeap (start, end) {\n    const val = (Buffer.from(\n      super.createByteStringFromHeap(start, end)\n    )).toString('hex')\n\n    return `h'${val}'`\n  }\n\n  createInfinity () {\n    return 'Infinity_1'\n  }\n\n  createInfinityNeg () {\n    return '-Infinity_1'\n  }\n\n  createNaN () {\n    return 'NaN_1'\n  }\n\n  createNaNNeg () {\n    return '-NaN_1'\n  }\n\n  createNull () {\n    return 'null'\n  }\n\n  createUndefined () {\n    return 'undefined'\n  }\n\n  createSimpleUnassigned (val) {\n    return `simple(${val})`\n  }\n\n  createArray (arr, len) {\n    const val = super.createArray(arr, len)\n\n    if (len === -1) {\n      // indefinite\n      return `[_ ${val.join(', ')}]`\n    }\n\n    return `[${val.join(', ')}]`\n  }\n\n  createMap (map, len) {\n    const val = super.createMap(map)\n    const list = Array.from(val.keys())\n      .reduce(collectObject(val), '')\n\n    if (len === -1) {\n      return `{_ ${list}}`\n    }\n\n    return `{${list}}`\n  }\n\n  createObject (obj, len) {\n    const val = super.createObject(obj)\n    const map = Object.keys(val)\n      .reduce(collectObject(val), '')\n\n    if (len === -1) {\n      return `{_ ${map}}`\n    }\n\n    return `{${map}}`\n  }\n\n  createUtf8String (raw, len) {\n    const val = raw.join(', ')\n\n    if (len === -1) {\n      return `(_ ${val})`\n    }\n\n    return `\"${val}\"`\n  }\n\n  createUtf8StringFromHeap (start, end) {\n    const val = (Buffer.from(\n      super.createUtf8StringFromHeap(start, end)\n    )).toString('utf8')\n\n    return `\"${val}\"`\n  }\n\n  static diagnose (input, enc) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, enc || 'hex')\n    }\n\n    const dec = new Diagnose()\n    return dec.decodeFirst(input)\n  }\n}\n\nmodule.exports = Diagnose\n\nfunction collectObject (val) {\n  return (acc, key) => {\n    if (acc) {\n      return `${acc}, ${key}: ${val[key]}`\n    }\n    return `${key}: ${val[key]}`\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2RpYWdub3NlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsK0RBQVc7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLDJEQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVUsR0FBRyxNQUFNO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsR0FBRztBQUNqQjs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxHQUFHO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSxjQUFjLEdBQUc7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCO0FBQ0EsZ0JBQWdCLElBQUk7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLElBQUk7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsSUFBSTtBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQzs7QUFFQSxlQUFlLGVBQWU7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLElBQUksTUFBTTtBQUN6Qjs7QUFFQSxhQUFhLEVBQUUsTUFBTTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsSUFBSSxLQUFLO0FBQ3hCOztBQUVBLGFBQWEsRUFBRSxLQUFLO0FBQ3BCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsSUFBSTtBQUN2Qjs7QUFFQSxlQUFlLElBQUk7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxJQUFJO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFJLElBQUksSUFBSSxJQUFJLFNBQVM7QUFDekM7QUFDQSxjQUFjLElBQUksSUFBSSxTQUFTO0FBQy9CO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ub2JvZHkxL1dvcmsvcTN4L3NjYWZmb2xkLWljcC9ub2RlX21vZHVsZXMvYm9yYy9zcmMvZGlhZ25vc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgRGVjb2RlciA9IHJlcXVpcmUoJy4vZGVjb2RlcicpXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuXG4vKipcbiAqIE91dHB1dCB0aGUgZGlhZ25vc3RpYyBmb3JtYXQgZnJvbSBhIHN0cmVhbSBvZiBDQk9SIGJ5dGVzLlxuICpcbiAqL1xuY2xhc3MgRGlhZ25vc2UgZXh0ZW5kcyBEZWNvZGVyIHtcbiAgY3JlYXRlVGFnICh0YWdOdW1iZXIsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGAke3RhZ051bWJlcn0oJHt2YWx1ZX0pYFxuICB9XG5cbiAgY3JlYXRlSW50ICh2YWwpIHtcbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlSW50KHZhbCkudG9TdHJpbmcoKVxuICB9XG5cbiAgY3JlYXRlSW50MzIgKGYsIGcpIHtcbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlSW50MzIoZiwgZykudG9TdHJpbmcoKVxuICB9XG5cbiAgY3JlYXRlSW50NjQgKGYxLCBmMiwgZzEsIGcyKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUludDY0KGYxLCBmMiwgZzEsIGcyKS50b1N0cmluZygpXG4gIH1cblxuICBjcmVhdGVJbnQzMk5lZyAoZiwgZykge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVJbnQzMk5lZyhmLCBnKS50b1N0cmluZygpXG4gIH1cblxuICBjcmVhdGVJbnQ2NE5lZyAoZjEsIGYyLCBnMSwgZzIpIHtcbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlSW50NjROZWcoZjEsIGYyLCBnMSwgZzIpLnRvU3RyaW5nKClcbiAgfVxuXG4gIGNyZWF0ZVRydWUgKCkge1xuICAgIHJldHVybiAndHJ1ZSdcbiAgfVxuXG4gIGNyZWF0ZUZhbHNlICgpIHtcbiAgICByZXR1cm4gJ2ZhbHNlJ1xuICB9XG5cbiAgY3JlYXRlRmxvYXQgKHZhbCkge1xuICAgIGNvbnN0IGZsID0gc3VwZXIuY3JlYXRlRmxvYXQodmFsKVxuICAgIGlmICh1dGlscy5pc05lZ2F0aXZlWmVybyh2YWwpKSB7XG4gICAgICByZXR1cm4gJy0wXzEnXG4gICAgfVxuXG4gICAgcmV0dXJuIGAke2ZsfV8xYFxuICB9XG5cbiAgY3JlYXRlRmxvYXRTaW5nbGUgKGEsIGIsIGMsIGQpIHtcbiAgICBjb25zdCBmbCA9IHN1cGVyLmNyZWF0ZUZsb2F0U2luZ2xlKGEsIGIsIGMsIGQpXG4gICAgcmV0dXJuIGAke2ZsfV8yYFxuICB9XG5cbiAgY3JlYXRlRmxvYXREb3VibGUgKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpIHtcbiAgICBjb25zdCBmbCA9IHN1cGVyLmNyZWF0ZUZsb2F0RG91YmxlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpXG4gICAgcmV0dXJuIGAke2ZsfV8zYFxuICB9XG5cbiAgY3JlYXRlQnl0ZVN0cmluZyAocmF3LCBsZW4pIHtcbiAgICBjb25zdCB2YWwgPSByYXcuam9pbignLCAnKVxuXG4gICAgaWYgKGxlbiA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBgKF8gJHt2YWx9KWBcbiAgICB9XG4gICAgcmV0dXJuIGBoJyR7dmFsfWBcbiAgfVxuXG4gIGNyZWF0ZUJ5dGVTdHJpbmdGcm9tSGVhcCAoc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IHZhbCA9IChCdWZmZXIuZnJvbShcbiAgICAgIHN1cGVyLmNyZWF0ZUJ5dGVTdHJpbmdGcm9tSGVhcChzdGFydCwgZW5kKVxuICAgICkpLnRvU3RyaW5nKCdoZXgnKVxuXG4gICAgcmV0dXJuIGBoJyR7dmFsfSdgXG4gIH1cblxuICBjcmVhdGVJbmZpbml0eSAoKSB7XG4gICAgcmV0dXJuICdJbmZpbml0eV8xJ1xuICB9XG5cbiAgY3JlYXRlSW5maW5pdHlOZWcgKCkge1xuICAgIHJldHVybiAnLUluZmluaXR5XzEnXG4gIH1cblxuICBjcmVhdGVOYU4gKCkge1xuICAgIHJldHVybiAnTmFOXzEnXG4gIH1cblxuICBjcmVhdGVOYU5OZWcgKCkge1xuICAgIHJldHVybiAnLU5hTl8xJ1xuICB9XG5cbiAgY3JlYXRlTnVsbCAoKSB7XG4gICAgcmV0dXJuICdudWxsJ1xuICB9XG5cbiAgY3JlYXRlVW5kZWZpbmVkICgpIHtcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCdcbiAgfVxuXG4gIGNyZWF0ZVNpbXBsZVVuYXNzaWduZWQgKHZhbCkge1xuICAgIHJldHVybiBgc2ltcGxlKCR7dmFsfSlgXG4gIH1cblxuICBjcmVhdGVBcnJheSAoYXJyLCBsZW4pIHtcbiAgICBjb25zdCB2YWwgPSBzdXBlci5jcmVhdGVBcnJheShhcnIsIGxlbilcblxuICAgIGlmIChsZW4gPT09IC0xKSB7XG4gICAgICAvLyBpbmRlZmluaXRlXG4gICAgICByZXR1cm4gYFtfICR7dmFsLmpvaW4oJywgJyl9XWBcbiAgICB9XG5cbiAgICByZXR1cm4gYFske3ZhbC5qb2luKCcsICcpfV1gXG4gIH1cblxuICBjcmVhdGVNYXAgKG1hcCwgbGVuKSB7XG4gICAgY29uc3QgdmFsID0gc3VwZXIuY3JlYXRlTWFwKG1hcClcbiAgICBjb25zdCBsaXN0ID0gQXJyYXkuZnJvbSh2YWwua2V5cygpKVxuICAgICAgLnJlZHVjZShjb2xsZWN0T2JqZWN0KHZhbCksICcnKVxuXG4gICAgaWYgKGxlbiA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBge18gJHtsaXN0fX1gXG4gICAgfVxuXG4gICAgcmV0dXJuIGB7JHtsaXN0fX1gXG4gIH1cblxuICBjcmVhdGVPYmplY3QgKG9iaiwgbGVuKSB7XG4gICAgY29uc3QgdmFsID0gc3VwZXIuY3JlYXRlT2JqZWN0KG9iailcbiAgICBjb25zdCBtYXAgPSBPYmplY3Qua2V5cyh2YWwpXG4gICAgICAucmVkdWNlKGNvbGxlY3RPYmplY3QodmFsKSwgJycpXG5cbiAgICBpZiAobGVuID09PSAtMSkge1xuICAgICAgcmV0dXJuIGB7XyAke21hcH19YFxuICAgIH1cblxuICAgIHJldHVybiBgeyR7bWFwfX1gXG4gIH1cblxuICBjcmVhdGVVdGY4U3RyaW5nIChyYXcsIGxlbikge1xuICAgIGNvbnN0IHZhbCA9IHJhdy5qb2luKCcsICcpXG5cbiAgICBpZiAobGVuID09PSAtMSkge1xuICAgICAgcmV0dXJuIGAoXyAke3ZhbH0pYFxuICAgIH1cblxuICAgIHJldHVybiBgXCIke3ZhbH1cImBcbiAgfVxuXG4gIGNyZWF0ZVV0ZjhTdHJpbmdGcm9tSGVhcCAoc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IHZhbCA9IChCdWZmZXIuZnJvbShcbiAgICAgIHN1cGVyLmNyZWF0ZVV0ZjhTdHJpbmdGcm9tSGVhcChzdGFydCwgZW5kKVxuICAgICkpLnRvU3RyaW5nKCd1dGY4JylcblxuICAgIHJldHVybiBgXCIke3ZhbH1cImBcbiAgfVxuXG4gIHN0YXRpYyBkaWFnbm9zZSAoaW5wdXQsIGVuYykge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpbnB1dCA9IEJ1ZmZlci5mcm9tKGlucHV0LCBlbmMgfHwgJ2hleCcpXG4gICAgfVxuXG4gICAgY29uc3QgZGVjID0gbmV3IERpYWdub3NlKClcbiAgICByZXR1cm4gZGVjLmRlY29kZUZpcnN0KGlucHV0KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlhZ25vc2VcblxuZnVuY3Rpb24gY29sbGVjdE9iamVjdCAodmFsKSB7XG4gIHJldHVybiAoYWNjLCBrZXkpID0+IHtcbiAgICBpZiAoYWNjKSB7XG4gICAgICByZXR1cm4gYCR7YWNjfSwgJHtrZXl9OiAke3ZhbFtrZXldfWBcbiAgICB9XG4gICAgcmV0dXJuIGAke2tleX06ICR7dmFsW2tleV19YFxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/borc/src/diagnose.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/borc/src/encoder.js":
/*!**********************************************!*\
  !*** ../../node_modules/borc/src/encoder.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\")\nconst { URL } = __webpack_require__(/*! iso-url */ \"(ssr)/../../node_modules/iso-url/index.js\")\nconst Bignumber = (__webpack_require__(/*! bignumber.js */ \"(ssr)/../../node_modules/bignumber.js/bignumber.js\").BigNumber)\n\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/../../node_modules/borc/src/utils.js\")\nconst constants = __webpack_require__(/*! ./constants */ \"(ssr)/../../node_modules/borc/src/constants.js\")\nconst MT = constants.MT\nconst NUMBYTES = constants.NUMBYTES\nconst SHIFT32 = constants.SHIFT32\nconst SYMS = constants.SYMS\nconst TAG = constants.TAG\nconst HALF = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.TWO\nconst FLOAT = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.FOUR\nconst DOUBLE = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.EIGHT\nconst TRUE = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.TRUE\nconst FALSE = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.FALSE\nconst UNDEFINED = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.UNDEFINED\nconst NULL = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.NULL\n\nconst MAXINT_BN = new Bignumber('0x20000000000000')\nconst BUF_NAN = Buffer.from('f97e00', 'hex')\nconst BUF_INF_NEG = Buffer.from('f9fc00', 'hex')\nconst BUF_INF_POS = Buffer.from('f97c00', 'hex')\n\nfunction toType (obj) {\n  // [object Type]\n  // --------8---1\n  return ({}).toString.call(obj).slice(8, -1)\n}\n\n/**\n * Transform JavaScript values into CBOR bytes\n *\n */\nclass Encoder {\n  /**\n   * @param {Object} [options={}]\n   * @param {function(Buffer)} options.stream\n   */\n  constructor (options) {\n    options = options || {}\n\n    this.streaming = typeof options.stream === 'function'\n    this.onData = options.stream\n\n    this.semanticTypes = [\n      [URL, this._pushUrl],\n      [Bignumber, this._pushBigNumber]\n    ]\n\n    const addTypes = options.genTypes || []\n    const len = addTypes.length\n    for (let i = 0; i < len; i++) {\n      this.addSemanticType(\n        addTypes[i][0],\n        addTypes[i][1]\n      )\n    }\n\n    this._reset()\n  }\n\n  addSemanticType (type, fun) {\n    const len = this.semanticTypes.length\n    for (let i = 0; i < len; i++) {\n      const typ = this.semanticTypes[i][0]\n      if (typ === type) {\n        const old = this.semanticTypes[i][1]\n        this.semanticTypes[i][1] = fun\n        return old\n      }\n    }\n    this.semanticTypes.push([type, fun])\n    return null\n  }\n\n  push (val) {\n    if (!val) {\n      return true\n    }\n\n    this.result[this.offset] = val\n    this.resultMethod[this.offset] = 0\n    this.resultLength[this.offset] = val.length\n    this.offset++\n\n    if (this.streaming) {\n      this.onData(this.finalize())\n    }\n\n    return true\n  }\n\n  pushWrite (val, method, len) {\n    this.result[this.offset] = val\n    this.resultMethod[this.offset] = method\n    this.resultLength[this.offset] = len\n    this.offset++\n\n    if (this.streaming) {\n      this.onData(this.finalize())\n    }\n\n    return true\n  }\n\n  _pushUInt8 (val) {\n    return this.pushWrite(val, 1, 1)\n  }\n\n  _pushUInt16BE (val) {\n    return this.pushWrite(val, 2, 2)\n  }\n\n  _pushUInt32BE (val) {\n    return this.pushWrite(val, 3, 4)\n  }\n\n  _pushDoubleBE (val) {\n    return this.pushWrite(val, 4, 8)\n  }\n\n  _pushNaN () {\n    return this.push(BUF_NAN)\n  }\n\n  _pushInfinity (obj) {\n    const half = (obj < 0) ? BUF_INF_NEG : BUF_INF_POS\n    return this.push(half)\n  }\n\n  _pushFloat (obj) {\n    const b2 = Buffer.allocUnsafe(2)\n\n    if (utils.writeHalf(b2, obj)) {\n      if (utils.parseHalf(b2) === obj) {\n        return this._pushUInt8(HALF) && this.push(b2)\n      }\n    }\n\n    const b4 = Buffer.allocUnsafe(4)\n    b4.writeFloatBE(obj, 0)\n    if (b4.readFloatBE(0) === obj) {\n      return this._pushUInt8(FLOAT) && this.push(b4)\n    }\n\n    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj)\n  }\n\n  _pushInt (obj, mt, orig) {\n    const m = mt << 5\n    if (obj < 24) {\n      return this._pushUInt8(m | obj)\n    }\n\n    if (obj <= 0xff) {\n      return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj)\n    }\n\n    if (obj <= 0xffff) {\n      return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj)\n    }\n\n    if (obj <= 0xffffffff) {\n      return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj)\n    }\n\n    if (obj <= Number.MAX_SAFE_INTEGER) {\n      return this._pushUInt8(m | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(Math.floor(obj / SHIFT32)) &&\n        this._pushUInt32BE(obj % SHIFT32)\n    }\n\n    if (mt === MT.NEG_INT) {\n      return this._pushFloat(orig)\n    }\n\n    return this._pushFloat(obj)\n  }\n\n  _pushIntNum (obj) {\n    if (obj < 0) {\n      return this._pushInt(-obj - 1, MT.NEG_INT, obj)\n    } else {\n      return this._pushInt(obj, MT.POS_INT)\n    }\n  }\n\n  _pushNumber (obj) {\n    switch (false) {\n      case (obj === obj): // eslint-disable-line\n        return this._pushNaN(obj)\n      case isFinite(obj):\n        return this._pushInfinity(obj)\n      case ((obj % 1) !== 0):\n        return this._pushIntNum(obj)\n      default:\n        return this._pushFloat(obj)\n    }\n  }\n\n  _pushString (obj) {\n    const len = Buffer.byteLength(obj, 'utf8')\n    return this._pushInt(len, MT.UTF8_STRING) && this.pushWrite(obj, 5, len)\n  }\n\n  _pushBoolean (obj) {\n    return this._pushUInt8(obj ? TRUE : FALSE)\n  }\n\n  _pushUndefined (obj) {\n    return this._pushUInt8(UNDEFINED)\n  }\n\n  _pushArray (gen, obj) {\n    const len = obj.length\n    if (!gen._pushInt(len, MT.ARRAY)) {\n      return false\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen.pushAny(obj[j])) {\n        return false\n      }\n    }\n    return true\n  }\n\n  _pushTag (tag) {\n    return this._pushInt(tag, MT.TAG)\n  }\n\n  _pushDate (gen, obj) {\n    // Round date, to get seconds since 1970-01-01 00:00:00 as defined in\n    // Sec. 2.4.1 and get a possibly more compact encoding. Note that it is\n    // still allowed to encode fractions of seconds which can be achieved by\n    // changing overwriting the encode function for Date objects.\n    return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(Math.round(obj / 1000))\n  }\n\n  _pushBuffer (gen, obj) {\n    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj)\n  }\n\n  _pushNoFilter (gen, obj) {\n    return gen._pushBuffer(gen, obj.slice())\n  }\n\n  _pushRegexp (gen, obj) {\n    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source)\n  }\n\n  _pushSet (gen, obj) {\n    if (!gen._pushInt(obj.size, MT.ARRAY)) {\n      return false\n    }\n    for (const x of obj) {\n      if (!gen.pushAny(x)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  _pushUrl (gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.format())\n  }\n\n  _pushBigint (obj) {\n    let tag = TAG.POS_BIGINT\n    if (obj.isNegative()) {\n      obj = obj.negated().minus(1)\n      tag = TAG.NEG_BIGINT\n    }\n    let str = obj.toString(16)\n    if (str.length % 2) {\n      str = '0' + str\n    }\n    const buf = Buffer.from(str, 'hex')\n    return this._pushTag(tag) && this._pushBuffer(this, buf)\n  }\n\n  _pushBigNumber (gen, obj) {\n    if (obj.isNaN()) {\n      return gen._pushNaN()\n    }\n    if (!obj.isFinite()) {\n      return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity)\n    }\n    if (obj.isInteger()) {\n      return gen._pushBigint(obj)\n    }\n    if (!(gen._pushTag(TAG.DECIMAL_FRAC) &&\n      gen._pushInt(2, MT.ARRAY))) {\n      return false\n    }\n\n    const dec = obj.decimalPlaces()\n    const slide = obj.multipliedBy(new Bignumber(10).pow(dec))\n    if (!gen._pushIntNum(-dec)) {\n      return false\n    }\n    if (slide.abs().isLessThan(MAXINT_BN)) {\n      return gen._pushIntNum(slide.toNumber())\n    } else {\n      return gen._pushBigint(slide)\n    }\n  }\n\n  _pushMap (gen, obj) {\n    if (!gen._pushInt(obj.size, MT.MAP)) {\n      return false\n    }\n\n    return this._pushRawMap(\n      obj.size,\n      Array.from(obj)\n    )\n  }\n\n  _pushObject (obj) {\n    if (!obj) {\n      return this._pushUInt8(NULL)\n    }\n\n    var len = this.semanticTypes.length\n    for (var i = 0; i < len; i++) {\n      if (obj instanceof this.semanticTypes[i][0]) {\n        return this.semanticTypes[i][1].call(obj, this, obj)\n      }\n    }\n\n    var f = obj.encodeCBOR\n    if (typeof f === 'function') {\n      return f.call(obj, this)\n    }\n\n    var keys = Object.keys(obj)\n    var keyLength = keys.length\n    if (!this._pushInt(keyLength, MT.MAP)) {\n      return false\n    }\n\n    return this._pushRawMap(\n      keyLength,\n      keys.map((k) => [k, obj[k]])\n    )\n  }\n\n  _pushRawMap (len, map) {\n    // Sort keys for canoncialization\n    // 1. encode key\n    // 2. shorter key comes before longer key\n    // 3. same length keys are sorted with lower\n    //    byte value before higher\n\n    map = map.map(function (a) {\n      a[0] = Encoder.encode(a[0])\n      return a\n    }).sort(utils.keySorter)\n\n    for (var j = 0; j < len; j++) {\n      if (!this.push(map[j][0])) {\n        return false\n      }\n\n      if (!this.pushAny(map[j][1])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Alias for `.pushAny`\n   *\n   * @param {*} obj\n   * @returns {boolean} true on success\n   */\n  write (obj) {\n    return this.pushAny(obj)\n  }\n\n  /**\n   * Push any supported type onto the encoded stream\n   *\n   * @param {any} obj\n   * @returns {boolean} true on success\n   */\n  pushAny (obj) {\n    var typ = toType(obj)\n\n    switch (typ) {\n      case 'Number':\n        return this._pushNumber(obj)\n      case 'String':\n        return this._pushString(obj)\n      case 'Boolean':\n        return this._pushBoolean(obj)\n      case 'Object':\n        return this._pushObject(obj)\n      case 'Array':\n        return this._pushArray(this, obj)\n      case 'Uint8Array':\n        return this._pushBuffer(this, Buffer.isBuffer(obj) ? obj : Buffer.from(obj))\n      case 'Null':\n        return this._pushUInt8(NULL)\n      case 'Undefined':\n        return this._pushUndefined(obj)\n      case 'Map':\n        return this._pushMap(this, obj)\n      case 'Set':\n        return this._pushSet(this, obj)\n      case 'URL':\n        return this._pushUrl(this, obj)\n      case 'BigNumber':\n        return this._pushBigNumber(this, obj)\n      case 'Date':\n        return this._pushDate(this, obj)\n      case 'RegExp':\n        return this._pushRegexp(this, obj)\n      case 'Symbol':\n        switch (obj) {\n          case SYMS.NULL:\n            return this._pushObject(null)\n          case SYMS.UNDEFINED:\n            return this._pushUndefined(undefined)\n          // TODO: Add pluggable support for other symbols\n          default:\n            throw new Error('Unknown symbol: ' + obj.toString())\n        }\n      default:\n        throw new Error('Unknown type: ' + typeof obj + ', ' + (obj ? obj.toString() : ''))\n    }\n  }\n\n  finalize () {\n    if (this.offset === 0) {\n      return null\n    }\n\n    var result = this.result\n    var resultLength = this.resultLength\n    var resultMethod = this.resultMethod\n    var offset = this.offset\n\n    // Determine the size of the buffer\n    var size = 0\n    var i = 0\n\n    for (; i < offset; i++) {\n      size += resultLength[i]\n    }\n\n    var res = Buffer.allocUnsafe(size)\n    var index = 0\n    var length = 0\n\n    // Write the content into the result buffer\n    for (i = 0; i < offset; i++) {\n      length = resultLength[i]\n\n      switch (resultMethod[i]) {\n        case 0:\n          result[i].copy(res, index)\n          break\n        case 1:\n          res.writeUInt8(result[i], index, true)\n          break\n        case 2:\n          res.writeUInt16BE(result[i], index, true)\n          break\n        case 3:\n          res.writeUInt32BE(result[i], index, true)\n          break\n        case 4:\n          res.writeDoubleBE(result[i], index, true)\n          break\n        case 5:\n          res.write(result[i], index, length, 'utf8')\n          break\n        default:\n          throw new Error('unkown method')\n      }\n\n      index += length\n    }\n\n    var tmp = res\n\n    this._reset()\n\n    return tmp\n  }\n\n  _reset () {\n    this.result = []\n    this.resultMethod = []\n    this.resultLength = []\n    this.offset = 0\n  }\n\n  /**\n   * Encode the given value\n   * @param {*} o\n   * @returns {Buffer}\n   */\n  static encode (o) {\n    const enc = new Encoder()\n    const ret = enc.pushAny(o)\n    if (!ret) {\n      throw new Error('Failed to encode input')\n    }\n\n    return enc.finalize()\n  }\n}\n\nmodule.exports = Encoder\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2VuY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNuQyxRQUFRLE1BQU0sRUFBRSxtQkFBTyxDQUFDLDBEQUFTO0FBQ2pDLGtCQUFrQix5R0FBaUM7O0FBRW5ELGNBQWMsbUJBQU8sQ0FBQywyREFBUztBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQyxtRUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUSxXQUFXO0FBQ2hDLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ub2JvZHkxL1dvcmsvcTN4L3NjYWZmb2xkLWljcC9ub2RlX21vZHVsZXMvYm9yYy9zcmMvZW5jb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSgnaXNvLXVybCcpXG5jb25zdCBCaWdudW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKS5CaWdOdW1iZXJcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IE1UID0gY29uc3RhbnRzLk1UXG5jb25zdCBOVU1CWVRFUyA9IGNvbnN0YW50cy5OVU1CWVRFU1xuY29uc3QgU0hJRlQzMiA9IGNvbnN0YW50cy5TSElGVDMyXG5jb25zdCBTWU1TID0gY29uc3RhbnRzLlNZTVNcbmNvbnN0IFRBRyA9IGNvbnN0YW50cy5UQUdcbmNvbnN0IEhBTEYgPSAoY29uc3RhbnRzLk1ULlNJTVBMRV9GTE9BVCA8PCA1KSB8IGNvbnN0YW50cy5OVU1CWVRFUy5UV09cbmNvbnN0IEZMT0FUID0gKGNvbnN0YW50cy5NVC5TSU1QTEVfRkxPQVQgPDwgNSkgfCBjb25zdGFudHMuTlVNQllURVMuRk9VUlxuY29uc3QgRE9VQkxFID0gKGNvbnN0YW50cy5NVC5TSU1QTEVfRkxPQVQgPDwgNSkgfCBjb25zdGFudHMuTlVNQllURVMuRUlHSFRcbmNvbnN0IFRSVUUgPSAoY29uc3RhbnRzLk1ULlNJTVBMRV9GTE9BVCA8PCA1KSB8IGNvbnN0YW50cy5TSU1QTEUuVFJVRVxuY29uc3QgRkFMU0UgPSAoY29uc3RhbnRzLk1ULlNJTVBMRV9GTE9BVCA8PCA1KSB8IGNvbnN0YW50cy5TSU1QTEUuRkFMU0VcbmNvbnN0IFVOREVGSU5FRCA9IChjb25zdGFudHMuTVQuU0lNUExFX0ZMT0FUIDw8IDUpIHwgY29uc3RhbnRzLlNJTVBMRS5VTkRFRklORURcbmNvbnN0IE5VTEwgPSAoY29uc3RhbnRzLk1ULlNJTVBMRV9GTE9BVCA8PCA1KSB8IGNvbnN0YW50cy5TSU1QTEUuTlVMTFxuXG5jb25zdCBNQVhJTlRfQk4gPSBuZXcgQmlnbnVtYmVyKCcweDIwMDAwMDAwMDAwMDAwJylcbmNvbnN0IEJVRl9OQU4gPSBCdWZmZXIuZnJvbSgnZjk3ZTAwJywgJ2hleCcpXG5jb25zdCBCVUZfSU5GX05FRyA9IEJ1ZmZlci5mcm9tKCdmOWZjMDAnLCAnaGV4JylcbmNvbnN0IEJVRl9JTkZfUE9TID0gQnVmZmVyLmZyb20oJ2Y5N2MwMCcsICdoZXgnKVxuXG5mdW5jdGlvbiB0b1R5cGUgKG9iaikge1xuICAvLyBbb2JqZWN0IFR5cGVdXG4gIC8vIC0tLS0tLS0tOC0tLTFcbiAgcmV0dXJuICh7fSkudG9TdHJpbmcuY2FsbChvYmopLnNsaWNlKDgsIC0xKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBKYXZhU2NyaXB0IHZhbHVlcyBpbnRvIENCT1IgYnl0ZXNcbiAqXG4gKi9cbmNsYXNzIEVuY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEJ1ZmZlcil9IG9wdGlvbnMuc3RyZWFtXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgICB0aGlzLnN0cmVhbWluZyA9IHR5cGVvZiBvcHRpb25zLnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJ1xuICAgIHRoaXMub25EYXRhID0gb3B0aW9ucy5zdHJlYW1cblxuICAgIHRoaXMuc2VtYW50aWNUeXBlcyA9IFtcbiAgICAgIFtVUkwsIHRoaXMuX3B1c2hVcmxdLFxuICAgICAgW0JpZ251bWJlciwgdGhpcy5fcHVzaEJpZ051bWJlcl1cbiAgICBdXG5cbiAgICBjb25zdCBhZGRUeXBlcyA9IG9wdGlvbnMuZ2VuVHlwZXMgfHwgW11cbiAgICBjb25zdCBsZW4gPSBhZGRUeXBlcy5sZW5ndGhcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLmFkZFNlbWFudGljVHlwZShcbiAgICAgICAgYWRkVHlwZXNbaV1bMF0sXG4gICAgICAgIGFkZFR5cGVzW2ldWzFdXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy5fcmVzZXQoKVxuICB9XG5cbiAgYWRkU2VtYW50aWNUeXBlICh0eXBlLCBmdW4pIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLnNlbWFudGljVHlwZXMubGVuZ3RoXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgdHlwID0gdGhpcy5zZW1hbnRpY1R5cGVzW2ldWzBdXG4gICAgICBpZiAodHlwID09PSB0eXBlKSB7XG4gICAgICAgIGNvbnN0IG9sZCA9IHRoaXMuc2VtYW50aWNUeXBlc1tpXVsxXVxuICAgICAgICB0aGlzLnNlbWFudGljVHlwZXNbaV1bMV0gPSBmdW5cbiAgICAgICAgcmV0dXJuIG9sZFxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNlbWFudGljVHlwZXMucHVzaChbdHlwZSwgZnVuXSlcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcHVzaCAodmFsKSB7XG4gICAgaWYgKCF2YWwpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgdGhpcy5yZXN1bHRbdGhpcy5vZmZzZXRdID0gdmFsXG4gICAgdGhpcy5yZXN1bHRNZXRob2RbdGhpcy5vZmZzZXRdID0gMFxuICAgIHRoaXMucmVzdWx0TGVuZ3RoW3RoaXMub2Zmc2V0XSA9IHZhbC5sZW5ndGhcbiAgICB0aGlzLm9mZnNldCsrXG5cbiAgICBpZiAodGhpcy5zdHJlYW1pbmcpIHtcbiAgICAgIHRoaXMub25EYXRhKHRoaXMuZmluYWxpemUoKSlcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcHVzaFdyaXRlICh2YWwsIG1ldGhvZCwgbGVuKSB7XG4gICAgdGhpcy5yZXN1bHRbdGhpcy5vZmZzZXRdID0gdmFsXG4gICAgdGhpcy5yZXN1bHRNZXRob2RbdGhpcy5vZmZzZXRdID0gbWV0aG9kXG4gICAgdGhpcy5yZXN1bHRMZW5ndGhbdGhpcy5vZmZzZXRdID0gbGVuXG4gICAgdGhpcy5vZmZzZXQrK1xuXG4gICAgaWYgKHRoaXMuc3RyZWFtaW5nKSB7XG4gICAgICB0aGlzLm9uRGF0YSh0aGlzLmZpbmFsaXplKCkpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIF9wdXNoVUludDggKHZhbCkge1xuICAgIHJldHVybiB0aGlzLnB1c2hXcml0ZSh2YWwsIDEsIDEpXG4gIH1cblxuICBfcHVzaFVJbnQxNkJFICh2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5wdXNoV3JpdGUodmFsLCAyLCAyKVxuICB9XG5cbiAgX3B1c2hVSW50MzJCRSAodmFsKSB7XG4gICAgcmV0dXJuIHRoaXMucHVzaFdyaXRlKHZhbCwgMywgNClcbiAgfVxuXG4gIF9wdXNoRG91YmxlQkUgKHZhbCkge1xuICAgIHJldHVybiB0aGlzLnB1c2hXcml0ZSh2YWwsIDQsIDgpXG4gIH1cblxuICBfcHVzaE5hTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHVzaChCVUZfTkFOKVxuICB9XG5cbiAgX3B1c2hJbmZpbml0eSAob2JqKSB7XG4gICAgY29uc3QgaGFsZiA9IChvYmogPCAwKSA/IEJVRl9JTkZfTkVHIDogQlVGX0lORl9QT1NcbiAgICByZXR1cm4gdGhpcy5wdXNoKGhhbGYpXG4gIH1cblxuICBfcHVzaEZsb2F0IChvYmopIHtcbiAgICBjb25zdCBiMiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKVxuXG4gICAgaWYgKHV0aWxzLndyaXRlSGFsZihiMiwgb2JqKSkge1xuICAgICAgaWYgKHV0aWxzLnBhcnNlSGFsZihiMikgPT09IG9iaikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KEhBTEYpICYmIHRoaXMucHVzaChiMilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBiNCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0KVxuICAgIGI0LndyaXRlRmxvYXRCRShvYmosIDApXG4gICAgaWYgKGI0LnJlYWRGbG9hdEJFKDApID09PSBvYmopIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgoRkxPQVQpICYmIHRoaXMucHVzaChiNClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KERPVUJMRSkgJiYgdGhpcy5fcHVzaERvdWJsZUJFKG9iailcbiAgfVxuXG4gIF9wdXNoSW50IChvYmosIG10LCBvcmlnKSB7XG4gICAgY29uc3QgbSA9IG10IDw8IDVcbiAgICBpZiAob2JqIDwgMjQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgobSB8IG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqIDw9IDB4ZmYpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgobSB8IE5VTUJZVEVTLk9ORSkgJiYgdGhpcy5fcHVzaFVJbnQ4KG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqIDw9IDB4ZmZmZikge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChtIHwgTlVNQllURVMuVFdPKSAmJiB0aGlzLl9wdXNoVUludDE2QkUob2JqKVxuICAgIH1cblxuICAgIGlmIChvYmogPD0gMHhmZmZmZmZmZikge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChtIHwgTlVNQllURVMuRk9VUikgJiYgdGhpcy5fcHVzaFVJbnQzMkJFKG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqIDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KG0gfCBOVU1CWVRFUy5FSUdIVCkgJiZcbiAgICAgICAgdGhpcy5fcHVzaFVJbnQzMkJFKE1hdGguZmxvb3Iob2JqIC8gU0hJRlQzMikpICYmXG4gICAgICAgIHRoaXMuX3B1c2hVSW50MzJCRShvYmogJSBTSElGVDMyKVxuICAgIH1cblxuICAgIGlmIChtdCA9PT0gTVQuTkVHX0lOVCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hGbG9hdChvcmlnKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wdXNoRmxvYXQob2JqKVxuICB9XG5cbiAgX3B1c2hJbnROdW0gKG9iaikge1xuICAgIGlmIChvYmogPCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaEludCgtb2JqIC0gMSwgTVQuTkVHX0lOVCwgb2JqKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaEludChvYmosIE1ULlBPU19JTlQpXG4gICAgfVxuICB9XG5cbiAgX3B1c2hOdW1iZXIgKG9iaikge1xuICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgIGNhc2UgKG9iaiA9PT0gb2JqKTogLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaE5hTihvYmopXG4gICAgICBjYXNlIGlzRmluaXRlKG9iaik6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoSW5maW5pdHkob2JqKVxuICAgICAgY2FzZSAoKG9iaiAlIDEpICE9PSAwKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hJbnROdW0ob2JqKVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hGbG9hdChvYmopXG4gICAgfVxuICB9XG5cbiAgX3B1c2hTdHJpbmcgKG9iaikge1xuICAgIGNvbnN0IGxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKG9iaiwgJ3V0ZjgnKVxuICAgIHJldHVybiB0aGlzLl9wdXNoSW50KGxlbiwgTVQuVVRGOF9TVFJJTkcpICYmIHRoaXMucHVzaFdyaXRlKG9iaiwgNSwgbGVuKVxuICB9XG5cbiAgX3B1c2hCb29sZWFuIChvYmopIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KG9iaiA/IFRSVUUgOiBGQUxTRSlcbiAgfVxuXG4gIF9wdXNoVW5kZWZpbmVkIChvYmopIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KFVOREVGSU5FRClcbiAgfVxuXG4gIF9wdXNoQXJyYXkgKGdlbiwgb2JqKSB7XG4gICAgY29uc3QgbGVuID0gb2JqLmxlbmd0aFxuICAgIGlmICghZ2VuLl9wdXNoSW50KGxlbiwgTVQuQVJSQVkpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgaWYgKCFnZW4ucHVzaEFueShvYmpbal0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgX3B1c2hUYWcgKHRhZykge1xuICAgIHJldHVybiB0aGlzLl9wdXNoSW50KHRhZywgTVQuVEFHKVxuICB9XG5cbiAgX3B1c2hEYXRlIChnZW4sIG9iaikge1xuICAgIC8vIFJvdW5kIGRhdGUsIHRvIGdldCBzZWNvbmRzIHNpbmNlIDE5NzAtMDEtMDEgMDA6MDA6MDAgYXMgZGVmaW5lZCBpblxuICAgIC8vIFNlYy4gMi40LjEgYW5kIGdldCBhIHBvc3NpYmx5IG1vcmUgY29tcGFjdCBlbmNvZGluZy4gTm90ZSB0aGF0IGl0IGlzXG4gICAgLy8gc3RpbGwgYWxsb3dlZCB0byBlbmNvZGUgZnJhY3Rpb25zIG9mIHNlY29uZHMgd2hpY2ggY2FuIGJlIGFjaGlldmVkIGJ5XG4gICAgLy8gY2hhbmdpbmcgb3ZlcndyaXRpbmcgdGhlIGVuY29kZSBmdW5jdGlvbiBmb3IgRGF0ZSBvYmplY3RzLlxuICAgIHJldHVybiBnZW4uX3B1c2hUYWcoVEFHLkRBVEVfRVBPQ0gpICYmIGdlbi5wdXNoQW55KE1hdGgucm91bmQob2JqIC8gMTAwMCkpXG4gIH1cblxuICBfcHVzaEJ1ZmZlciAoZ2VuLCBvYmopIHtcbiAgICByZXR1cm4gZ2VuLl9wdXNoSW50KG9iai5sZW5ndGgsIE1ULkJZVEVfU1RSSU5HKSAmJiBnZW4ucHVzaChvYmopXG4gIH1cblxuICBfcHVzaE5vRmlsdGVyIChnZW4sIG9iaikge1xuICAgIHJldHVybiBnZW4uX3B1c2hCdWZmZXIoZ2VuLCBvYmouc2xpY2UoKSlcbiAgfVxuXG4gIF9wdXNoUmVnZXhwIChnZW4sIG9iaikge1xuICAgIHJldHVybiBnZW4uX3B1c2hUYWcoVEFHLlJFR0VYUCkgJiYgZ2VuLnB1c2hBbnkob2JqLnNvdXJjZSlcbiAgfVxuXG4gIF9wdXNoU2V0IChnZW4sIG9iaikge1xuICAgIGlmICghZ2VuLl9wdXNoSW50KG9iai5zaXplLCBNVC5BUlJBWSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHggb2Ygb2JqKSB7XG4gICAgICBpZiAoIWdlbi5wdXNoQW55KHgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgX3B1c2hVcmwgKGdlbiwgb2JqKSB7XG4gICAgcmV0dXJuIGdlbi5fcHVzaFRhZyhUQUcuVVJJKSAmJiBnZW4ucHVzaEFueShvYmouZm9ybWF0KCkpXG4gIH1cblxuICBfcHVzaEJpZ2ludCAob2JqKSB7XG4gICAgbGV0IHRhZyA9IFRBRy5QT1NfQklHSU5UXG4gICAgaWYgKG9iai5pc05lZ2F0aXZlKCkpIHtcbiAgICAgIG9iaiA9IG9iai5uZWdhdGVkKCkubWludXMoMSlcbiAgICAgIHRhZyA9IFRBRy5ORUdfQklHSU5UXG4gICAgfVxuICAgIGxldCBzdHIgPSBvYmoudG9TdHJpbmcoMTYpXG4gICAgaWYgKHN0ci5sZW5ndGggJSAyKSB7XG4gICAgICBzdHIgPSAnMCcgKyBzdHJcbiAgICB9XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20oc3RyLCAnaGV4JylcbiAgICByZXR1cm4gdGhpcy5fcHVzaFRhZyh0YWcpICYmIHRoaXMuX3B1c2hCdWZmZXIodGhpcywgYnVmKVxuICB9XG5cbiAgX3B1c2hCaWdOdW1iZXIgKGdlbiwgb2JqKSB7XG4gICAgaWYgKG9iai5pc05hTigpKSB7XG4gICAgICByZXR1cm4gZ2VuLl9wdXNoTmFOKClcbiAgICB9XG4gICAgaWYgKCFvYmouaXNGaW5pdGUoKSkge1xuICAgICAgcmV0dXJuIGdlbi5fcHVzaEluZmluaXR5KG9iai5pc05lZ2F0aXZlKCkgPyAtSW5maW5pdHkgOiBJbmZpbml0eSlcbiAgICB9XG4gICAgaWYgKG9iai5pc0ludGVnZXIoKSkge1xuICAgICAgcmV0dXJuIGdlbi5fcHVzaEJpZ2ludChvYmopXG4gICAgfVxuICAgIGlmICghKGdlbi5fcHVzaFRhZyhUQUcuREVDSU1BTF9GUkFDKSAmJlxuICAgICAgZ2VuLl9wdXNoSW50KDIsIE1ULkFSUkFZKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IGRlYyA9IG9iai5kZWNpbWFsUGxhY2VzKClcbiAgICBjb25zdCBzbGlkZSA9IG9iai5tdWx0aXBsaWVkQnkobmV3IEJpZ251bWJlcigxMCkucG93KGRlYykpXG4gICAgaWYgKCFnZW4uX3B1c2hJbnROdW0oLWRlYykpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAoc2xpZGUuYWJzKCkuaXNMZXNzVGhhbihNQVhJTlRfQk4pKSB7XG4gICAgICByZXR1cm4gZ2VuLl9wdXNoSW50TnVtKHNsaWRlLnRvTnVtYmVyKCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZW4uX3B1c2hCaWdpbnQoc2xpZGUpXG4gICAgfVxuICB9XG5cbiAgX3B1c2hNYXAgKGdlbiwgb2JqKSB7XG4gICAgaWYgKCFnZW4uX3B1c2hJbnQob2JqLnNpemUsIE1ULk1BUCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wdXNoUmF3TWFwKFxuICAgICAgb2JqLnNpemUsXG4gICAgICBBcnJheS5mcm9tKG9iailcbiAgICApXG4gIH1cblxuICBfcHVzaE9iamVjdCAob2JqKSB7XG4gICAgaWYgKCFvYmopIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgoTlVMTClcbiAgICB9XG5cbiAgICB2YXIgbGVuID0gdGhpcy5zZW1hbnRpY1R5cGVzLmxlbmd0aFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiB0aGlzLnNlbWFudGljVHlwZXNbaV1bMF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VtYW50aWNUeXBlc1tpXVsxXS5jYWxsKG9iaiwgdGhpcywgb2JqKVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmID0gb2JqLmVuY29kZUNCT1JcbiAgICBpZiAodHlwZW9mIGYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBmLmNhbGwob2JqLCB0aGlzKVxuICAgIH1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKVxuICAgIHZhciBrZXlMZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgIGlmICghdGhpcy5fcHVzaEludChrZXlMZW5ndGgsIE1ULk1BUCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wdXNoUmF3TWFwKFxuICAgICAga2V5TGVuZ3RoLFxuICAgICAga2V5cy5tYXAoKGspID0+IFtrLCBvYmpba11dKVxuICAgIClcbiAgfVxuXG4gIF9wdXNoUmF3TWFwIChsZW4sIG1hcCkge1xuICAgIC8vIFNvcnQga2V5cyBmb3IgY2Fub25jaWFsaXphdGlvblxuICAgIC8vIDEuIGVuY29kZSBrZXlcbiAgICAvLyAyLiBzaG9ydGVyIGtleSBjb21lcyBiZWZvcmUgbG9uZ2VyIGtleVxuICAgIC8vIDMuIHNhbWUgbGVuZ3RoIGtleXMgYXJlIHNvcnRlZCB3aXRoIGxvd2VyXG4gICAgLy8gICAgYnl0ZSB2YWx1ZSBiZWZvcmUgaGlnaGVyXG5cbiAgICBtYXAgPSBtYXAubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICBhWzBdID0gRW5jb2Rlci5lbmNvZGUoYVswXSlcbiAgICAgIHJldHVybiBhXG4gICAgfSkuc29ydCh1dGlscy5rZXlTb3J0ZXIpXG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBpZiAoIXRoaXMucHVzaChtYXBbal1bMF0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMucHVzaEFueShtYXBbal1bMV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQWxpYXMgZm9yIGAucHVzaEFueWBcbiAgICpcbiAgICogQHBhcmFtIHsqfSBvYmpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb24gc3VjY2Vzc1xuICAgKi9cbiAgd3JpdGUgKG9iaikge1xuICAgIHJldHVybiB0aGlzLnB1c2hBbnkob2JqKVxuICB9XG5cbiAgLyoqXG4gICAqIFB1c2ggYW55IHN1cHBvcnRlZCB0eXBlIG9udG8gdGhlIGVuY29kZWQgc3RyZWFtXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBvYmpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb24gc3VjY2Vzc1xuICAgKi9cbiAgcHVzaEFueSAob2JqKSB7XG4gICAgdmFyIHR5cCA9IHRvVHlwZShvYmopXG5cbiAgICBzd2l0Y2ggKHR5cCkge1xuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hOdW1iZXIob2JqKVxuICAgICAgY2FzZSAnU3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hTdHJpbmcob2JqKVxuICAgICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoQm9vbGVhbihvYmopXG4gICAgICBjYXNlICdPYmplY3QnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaE9iamVjdChvYmopXG4gICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoQXJyYXkodGhpcywgb2JqKVxuICAgICAgY2FzZSAnVWludDhBcnJheSc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoQnVmZmVyKHRoaXMsIEJ1ZmZlci5pc0J1ZmZlcihvYmopID8gb2JqIDogQnVmZmVyLmZyb20ob2JqKSlcbiAgICAgIGNhc2UgJ051bGwnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KE5VTEwpXG4gICAgICBjYXNlICdVbmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaFVuZGVmaW5lZChvYmopXG4gICAgICBjYXNlICdNYXAnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaE1hcCh0aGlzLCBvYmopXG4gICAgICBjYXNlICdTZXQnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaFNldCh0aGlzLCBvYmopXG4gICAgICBjYXNlICdVUkwnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaFVybCh0aGlzLCBvYmopXG4gICAgICBjYXNlICdCaWdOdW1iZXInOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEJpZ051bWJlcih0aGlzLCBvYmopXG4gICAgICBjYXNlICdEYXRlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hEYXRlKHRoaXMsIG9iailcbiAgICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoUmVnZXhwKHRoaXMsIG9iailcbiAgICAgIGNhc2UgJ1N5bWJvbCc6XG4gICAgICAgIHN3aXRjaCAob2JqKSB7XG4gICAgICAgICAgY2FzZSBTWU1TLk5VTEw6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHVzaE9iamVjdChudWxsKVxuICAgICAgICAgIGNhc2UgU1lNUy5VTkRFRklORUQ6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHVzaFVuZGVmaW5lZCh1bmRlZmluZWQpXG4gICAgICAgICAgLy8gVE9ETzogQWRkIHBsdWdnYWJsZSBzdXBwb3J0IGZvciBvdGhlciBzeW1ib2xzXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBzeW1ib2w6ICcgKyBvYmoudG9TdHJpbmcoKSlcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyB0eXBlb2Ygb2JqICsgJywgJyArIChvYmogPyBvYmoudG9TdHJpbmcoKSA6ICcnKSlcbiAgICB9XG4gIH1cblxuICBmaW5hbGl6ZSAoKSB7XG4gICAgaWYgKHRoaXMub2Zmc2V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdFxuICAgIHZhciByZXN1bHRMZW5ndGggPSB0aGlzLnJlc3VsdExlbmd0aFxuICAgIHZhciByZXN1bHRNZXRob2QgPSB0aGlzLnJlc3VsdE1ldGhvZFxuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldFxuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSBidWZmZXJcbiAgICB2YXIgc2l6ZSA9IDBcbiAgICB2YXIgaSA9IDBcblxuICAgIGZvciAoOyBpIDwgb2Zmc2V0OyBpKyspIHtcbiAgICAgIHNpemUgKz0gcmVzdWx0TGVuZ3RoW2ldXG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKVxuICAgIHZhciBpbmRleCA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuXG4gICAgLy8gV3JpdGUgdGhlIGNvbnRlbnQgaW50byB0aGUgcmVzdWx0IGJ1ZmZlclxuICAgIGZvciAoaSA9IDA7IGkgPCBvZmZzZXQ7IGkrKykge1xuICAgICAgbGVuZ3RoID0gcmVzdWx0TGVuZ3RoW2ldXG5cbiAgICAgIHN3aXRjaCAocmVzdWx0TWV0aG9kW2ldKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXN1bHRbaV0uY29weShyZXMsIGluZGV4KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXMud3JpdGVVSW50OChyZXN1bHRbaV0sIGluZGV4LCB0cnVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXMud3JpdGVVSW50MTZCRShyZXN1bHRbaV0sIGluZGV4LCB0cnVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXMud3JpdGVVSW50MzJCRShyZXN1bHRbaV0sIGluZGV4LCB0cnVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXMud3JpdGVEb3VibGVCRShyZXN1bHRbaV0sIGluZGV4LCB0cnVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXMud3JpdGUocmVzdWx0W2ldLCBpbmRleCwgbGVuZ3RoLCAndXRmOCcpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua293biBtZXRob2QnKVxuICAgICAgfVxuXG4gICAgICBpbmRleCArPSBsZW5ndGhcbiAgICB9XG5cbiAgICB2YXIgdG1wID0gcmVzXG5cbiAgICB0aGlzLl9yZXNldCgpXG5cbiAgICByZXR1cm4gdG1wXG4gIH1cblxuICBfcmVzZXQgKCkge1xuICAgIHRoaXMucmVzdWx0ID0gW11cbiAgICB0aGlzLnJlc3VsdE1ldGhvZCA9IFtdXG4gICAgdGhpcy5yZXN1bHRMZW5ndGggPSBbXVxuICAgIHRoaXMub2Zmc2V0ID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSB0aGUgZ2l2ZW4gdmFsdWVcbiAgICogQHBhcmFtIHsqfSBvXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gICAqL1xuICBzdGF0aWMgZW5jb2RlIChvKSB7XG4gICAgY29uc3QgZW5jID0gbmV3IEVuY29kZXIoKVxuICAgIGNvbnN0IHJldCA9IGVuYy5wdXNoQW55KG8pXG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGVuY29kZSBpbnB1dCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIGVuYy5maW5hbGl6ZSgpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFbmNvZGVyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/borc/src/encoder.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/borc/src/index.js":
/*!********************************************!*\
  !*** ../../node_modules/borc/src/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n// exports.Commented = require('./commented')\nexports.Diagnose = __webpack_require__(/*! ./diagnose */ \"(ssr)/../../node_modules/borc/src/diagnose.js\")\nexports.Decoder = __webpack_require__(/*! ./decoder */ \"(ssr)/../../node_modules/borc/src/decoder.js\")\nexports.Encoder = __webpack_require__(/*! ./encoder */ \"(ssr)/../../node_modules/borc/src/encoder.js\")\nexports.Simple = __webpack_require__(/*! ./simple */ \"(ssr)/../../node_modules/borc/src/simple.js\")\nexports.Tagged = __webpack_require__(/*! ./tagged */ \"(ssr)/../../node_modules/borc/src/tagged.js\")\n\n// exports.comment = exports.Commented.comment\nexports.decodeAll = exports.Decoder.decodeAll\nexports.decodeFirst = exports.Decoder.decodeFirst\nexports.diagnose = exports.Diagnose.diagnose\nexports.encode = exports.Encoder.encode\nexports.decode = exports.Decoder.decode\n\nexports.leveldb = {\n  decode: exports.Decoder.decodeAll,\n  encode: exports.Encoder.encode,\n  buffer: true,\n  name: 'cbor'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0EseUdBQXdDO0FBQ3hDLHNHQUFzQztBQUN0QyxzR0FBc0M7QUFDdEMsbUdBQW9DO0FBQ3BDLG1HQUFvQzs7QUFFcEM7QUFDQSxpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsY0FBYzs7QUFFZCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL25vYm9keTEvV29yay9xM3gvc2NhZmZvbGQtaWNwL25vZGVfbW9kdWxlcy9ib3JjL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gZXhwb3J0cy5Db21tZW50ZWQgPSByZXF1aXJlKCcuL2NvbW1lbnRlZCcpXG5leHBvcnRzLkRpYWdub3NlID0gcmVxdWlyZSgnLi9kaWFnbm9zZScpXG5leHBvcnRzLkRlY29kZXIgPSByZXF1aXJlKCcuL2RlY29kZXInKVxuZXhwb3J0cy5FbmNvZGVyID0gcmVxdWlyZSgnLi9lbmNvZGVyJylcbmV4cG9ydHMuU2ltcGxlID0gcmVxdWlyZSgnLi9zaW1wbGUnKVxuZXhwb3J0cy5UYWdnZWQgPSByZXF1aXJlKCcuL3RhZ2dlZCcpXG5cbi8vIGV4cG9ydHMuY29tbWVudCA9IGV4cG9ydHMuQ29tbWVudGVkLmNvbW1lbnRcbmV4cG9ydHMuZGVjb2RlQWxsID0gZXhwb3J0cy5EZWNvZGVyLmRlY29kZUFsbFxuZXhwb3J0cy5kZWNvZGVGaXJzdCA9IGV4cG9ydHMuRGVjb2Rlci5kZWNvZGVGaXJzdFxuZXhwb3J0cy5kaWFnbm9zZSA9IGV4cG9ydHMuRGlhZ25vc2UuZGlhZ25vc2VcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5FbmNvZGVyLmVuY29kZVxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLkRlY29kZXIuZGVjb2RlXG5cbmV4cG9ydHMubGV2ZWxkYiA9IHtcbiAgZGVjb2RlOiBleHBvcnRzLkRlY29kZXIuZGVjb2RlQWxsLFxuICBlbmNvZGU6IGV4cG9ydHMuRW5jb2Rlci5lbmNvZGUsXG4gIGJ1ZmZlcjogdHJ1ZSxcbiAgbmFtZTogJ2Nib3InXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/borc/src/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/borc/src/simple.js":
/*!*********************************************!*\
  !*** ../../node_modules/borc/src/simple.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst constants = __webpack_require__(/*! ./constants */ \"(ssr)/../../node_modules/borc/src/constants.js\")\nconst MT = constants.MT\nconst SIMPLE = constants.SIMPLE\nconst SYMS = constants.SYMS\n\n/**\n * A CBOR Simple Value that does not map onto a known constant.\n */\nclass Simple {\n  /**\n   * Creates an instance of Simple.\n   *\n   * @param {integer} value - the simple value's integer value\n   */\n  constructor (value) {\n    if (typeof value !== 'number') {\n      throw new Error('Invalid Simple type: ' + (typeof value))\n    }\n    if ((value < 0) || (value > 255) || ((value | 0) !== value)) {\n      throw new Error('value must be a small positive integer: ' + value)\n    }\n    this.value = value\n  }\n\n  /**\n   * Debug string for simple value\n   *\n   * @returns {string} simple(value)\n   */\n  toString () {\n    return 'simple(' + this.value + ')'\n  }\n\n  /**\n   * Debug string for simple value\n   *\n   * @returns {string} simple(value)\n   */\n  inspect () {\n    return 'simple(' + this.value + ')'\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {cbor.Encoder} gen The generator to push onto\n   * @returns {number}\n   */\n  encodeCBOR (gen) {\n    return gen._pushInt(this.value, MT.SIMPLE_FLOAT)\n  }\n\n  /**\n   * Is the given object a Simple?\n   *\n   * @param {any} obj - object to test\n   * @returns {bool} - is it Simple?\n   */\n  static isSimple (obj) {\n    return obj instanceof Simple\n  }\n\n  /**\n   * Decode from the CBOR additional information into a JavaScript value.\n   * If the CBOR item has no parent, return a \"safe\" symbol instead of\n   * `null` or `undefined`, so that the value can be passed through a\n   * stream in object mode.\n   *\n   * @param {Number} val - the CBOR additional info to convert\n   * @param {bool} hasParent - Does the CBOR item have a parent?\n   * @returns {(null|undefined|Boolean|Symbol)} - the decoded value\n   */\n  static decode (val, hasParent) {\n    if (hasParent == null) {\n      hasParent = true\n    }\n    switch (val) {\n      case SIMPLE.FALSE:\n        return false\n      case SIMPLE.TRUE:\n        return true\n      case SIMPLE.NULL:\n        if (hasParent) {\n          return null\n        } else {\n          return SYMS.NULL\n        }\n      case SIMPLE.UNDEFINED:\n        if (hasParent) {\n          return undefined\n        } else {\n          return SYMS.UNDEFINED\n        }\n      case -1:\n        if (!hasParent) {\n          throw new Error('Invalid BREAK')\n        }\n        return SYMS.BREAK\n      default:\n        return new Simple(val)\n    }\n  }\n}\n\nmodule.exports = Simple\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL3NpbXBsZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixrQkFBa0IsbUJBQU8sQ0FBQyxtRUFBYTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsTUFBTTtBQUNuQixlQUFlLGlDQUFpQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL25vYm9keTEvV29yay9xM3gvc2NhZmZvbGQtaWNwL25vZGVfbW9kdWxlcy9ib3JjL3NyYy9zaW1wbGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IE1UID0gY29uc3RhbnRzLk1UXG5jb25zdCBTSU1QTEUgPSBjb25zdGFudHMuU0lNUExFXG5jb25zdCBTWU1TID0gY29uc3RhbnRzLlNZTVNcblxuLyoqXG4gKiBBIENCT1IgU2ltcGxlIFZhbHVlIHRoYXQgZG9lcyBub3QgbWFwIG9udG8gYSBrbm93biBjb25zdGFudC5cbiAqL1xuY2xhc3MgU2ltcGxlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgU2ltcGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIC0gdGhlIHNpbXBsZSB2YWx1ZSdzIGludGVnZXIgdmFsdWVcbiAgICovXG4gIGNvbnN0cnVjdG9yICh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgU2ltcGxlIHR5cGU6ICcgKyAodHlwZW9mIHZhbHVlKSlcbiAgICB9XG4gICAgaWYgKCh2YWx1ZSA8IDApIHx8ICh2YWx1ZSA+IDI1NSkgfHwgKCh2YWx1ZSB8IDApICE9PSB2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgbXVzdCBiZSBhIHNtYWxsIHBvc2l0aXZlIGludGVnZXI6ICcgKyB2YWx1ZSlcbiAgICB9XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogRGVidWcgc3RyaW5nIGZvciBzaW1wbGUgdmFsdWVcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gc2ltcGxlKHZhbHVlKVxuICAgKi9cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiAnc2ltcGxlKCcgKyB0aGlzLnZhbHVlICsgJyknXG4gIH1cblxuICAvKipcbiAgICogRGVidWcgc3RyaW5nIGZvciBzaW1wbGUgdmFsdWVcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gc2ltcGxlKHZhbHVlKVxuICAgKi9cbiAgaW5zcGVjdCAoKSB7XG4gICAgcmV0dXJuICdzaW1wbGUoJyArIHRoaXMudmFsdWUgKyAnKSdcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIHRoZSBzaW1wbGUgdmFsdWUgb250byB0aGUgQ0JPUiBzdHJlYW1cbiAgICpcbiAgICogQHBhcmFtIHtjYm9yLkVuY29kZXJ9IGdlbiBUaGUgZ2VuZXJhdG9yIHRvIHB1c2ggb250b1xuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZW5jb2RlQ0JPUiAoZ2VuKSB7XG4gICAgcmV0dXJuIGdlbi5fcHVzaEludCh0aGlzLnZhbHVlLCBNVC5TSU1QTEVfRkxPQVQpXG4gIH1cblxuICAvKipcbiAgICogSXMgdGhlIGdpdmVuIG9iamVjdCBhIFNpbXBsZT9cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IG9iaiAtIG9iamVjdCB0byB0ZXN0XG4gICAqIEByZXR1cm5zIHtib29sfSAtIGlzIGl0IFNpbXBsZT9cbiAgICovXG4gIHN0YXRpYyBpc1NpbXBsZSAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIFNpbXBsZVxuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBmcm9tIHRoZSBDQk9SIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gaW50byBhIEphdmFTY3JpcHQgdmFsdWUuXG4gICAqIElmIHRoZSBDQk9SIGl0ZW0gaGFzIG5vIHBhcmVudCwgcmV0dXJuIGEgXCJzYWZlXCIgc3ltYm9sIGluc3RlYWQgb2ZcbiAgICogYG51bGxgIG9yIGB1bmRlZmluZWRgLCBzbyB0aGF0IHRoZSB2YWx1ZSBjYW4gYmUgcGFzc2VkIHRocm91Z2ggYVxuICAgKiBzdHJlYW0gaW4gb2JqZWN0IG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWwgLSB0aGUgQ0JPUiBhZGRpdGlvbmFsIGluZm8gdG8gY29udmVydFxuICAgKiBAcGFyYW0ge2Jvb2x9IGhhc1BhcmVudCAtIERvZXMgdGhlIENCT1IgaXRlbSBoYXZlIGEgcGFyZW50P1xuICAgKiBAcmV0dXJucyB7KG51bGx8dW5kZWZpbmVkfEJvb2xlYW58U3ltYm9sKX0gLSB0aGUgZGVjb2RlZCB2YWx1ZVxuICAgKi9cbiAgc3RhdGljIGRlY29kZSAodmFsLCBoYXNQYXJlbnQpIHtcbiAgICBpZiAoaGFzUGFyZW50ID09IG51bGwpIHtcbiAgICAgIGhhc1BhcmVudCA9IHRydWVcbiAgICB9XG4gICAgc3dpdGNoICh2YWwpIHtcbiAgICAgIGNhc2UgU0lNUExFLkZBTFNFOlxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIGNhc2UgU0lNUExFLlRSVUU6XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICBjYXNlIFNJTVBMRS5OVUxMOlxuICAgICAgICBpZiAoaGFzUGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gU1lNUy5OVUxMXG4gICAgICAgIH1cbiAgICAgIGNhc2UgU0lNUExFLlVOREVGSU5FRDpcbiAgICAgICAgaWYgKGhhc1BhcmVudCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gU1lNUy5VTkRFRklORURcbiAgICAgICAgfVxuICAgICAgY2FzZSAtMTpcbiAgICAgICAgaWYgKCFoYXNQYXJlbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQlJFQUsnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTWU1TLkJSRUFLXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbmV3IFNpbXBsZSh2YWwpXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2ltcGxlXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/borc/src/simple.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/borc/src/tagged.js":
/*!*********************************************!*\
  !*** ../../node_modules/borc/src/tagged.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\nclass Tagged {\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {Number} tag - the number of the tag\n   * @param {any} value - the value inside the tag\n   * @param {Error} err - the error that was thrown parsing the tag, or null\n   */\n  constructor (tag, value, err) {\n    this.tag = tag\n    this.value = value\n    this.err = err\n    if (typeof this.tag !== 'number') {\n      throw new Error('Invalid tag type (' + (typeof this.tag) + ')')\n    }\n    if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {\n      throw new Error('Tag must be a positive integer: ' + this.tag)\n    }\n  }\n\n  /**\n   * Convert to a String\n   *\n   * @returns {String} string of the form '1(2)'\n   */\n  toString () {\n    return `${this.tag}(${JSON.stringify(this.value)})`\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {cbor.Encoder} gen The generator to push onto\n   * @returns {number}\n   */\n  encodeCBOR (gen) {\n    gen._pushTag(this.tag)\n    return gen.pushAny(this.value)\n  }\n\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {Object} converters - keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} - the converted item\n   */\n  convert (converters) {\n    var er, f\n    f = converters != null ? converters[this.tag] : undefined\n    if (typeof f !== 'function') {\n      f = Tagged['_tag' + this.tag]\n      if (typeof f !== 'function') {\n        return this\n      }\n    }\n    try {\n      return f.call(Tagged, this.value)\n    } catch (error) {\n      er = error\n      this.err = er\n      return this\n    }\n  }\n}\n\nmodule.exports = Tagged\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL3RhZ2dlZC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLFNBQVMsR0FBRywyQkFBMkI7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ub2JvZHkxL1dvcmsvcTN4L3NjYWZmb2xkLWljcC9ub2RlX21vZHVsZXMvYm9yYy9zcmMvdGFnZ2VkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEEgQ0JPUiB0YWdnZWQgaXRlbSwgd2hlcmUgdGhlIHRhZyBkb2VzIG5vdCBoYXZlIHNlbWFudGljcyBzcGVjaWZpZWQgYXQgdGhlXG4gKiBtb21lbnQsIG9yIHRob3NlIHNlbWFudGljcyB0aHJldyBhbiBlcnJvciBkdXJpbmcgcGFyc2luZy4gVHlwaWNhbGx5IHRoaXMgd2lsbFxuICogYmUgYW4gZXh0ZW5zaW9uIHBvaW50IHlvdSdyZSBub3QgeWV0IGV4cGVjdGluZy5cbiAqL1xuY2xhc3MgVGFnZ2VkIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgVGFnZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGFnIC0gdGhlIG51bWJlciBvZiB0aGUgdGFnXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIHRoZSB2YWx1ZSBpbnNpZGUgdGhlIHRhZ1xuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSB0aGUgZXJyb3IgdGhhdCB3YXMgdGhyb3duIHBhcnNpbmcgdGhlIHRhZywgb3IgbnVsbFxuICAgKi9cbiAgY29uc3RydWN0b3IgKHRhZywgdmFsdWUsIGVycikge1xuICAgIHRoaXMudGFnID0gdGFnXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gICAgdGhpcy5lcnIgPSBlcnJcbiAgICBpZiAodHlwZW9mIHRoaXMudGFnICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhZyB0eXBlICgnICsgKHR5cGVvZiB0aGlzLnRhZykgKyAnKScpXG4gICAgfVxuICAgIGlmICgodGhpcy50YWcgPCAwKSB8fCAoKHRoaXMudGFnIHwgMCkgIT09IHRoaXMudGFnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYWcgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXI6ICcgKyB0aGlzLnRhZylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0byBhIFN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgb2YgdGhlIGZvcm0gJzEoMiknXG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMudGFnfSgke0pTT04uc3RyaW5naWZ5KHRoaXMudmFsdWUpfSlgXG4gIH1cblxuICAvKipcbiAgICogUHVzaCB0aGUgc2ltcGxlIHZhbHVlIG9udG8gdGhlIENCT1Igc3RyZWFtXG4gICAqXG4gICAqIEBwYXJhbSB7Y2Jvci5FbmNvZGVyfSBnZW4gVGhlIGdlbmVyYXRvciB0byBwdXNoIG9udG9cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGVuY29kZUNCT1IgKGdlbikge1xuICAgIGdlbi5fcHVzaFRhZyh0aGlzLnRhZylcbiAgICByZXR1cm4gZ2VuLnB1c2hBbnkodGhpcy52YWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB3ZSBoYXZlIGEgY29udmVydGVyIGZvciB0aGlzIHR5cGUsIGRvIHRoZSBjb252ZXJzaW9uLiAgU29tZSBjb252ZXJ0ZXJzXG4gICAqIGFyZSBidWlsdC1pbi4gIEFkZGl0aW9uYWwgb25lcyBjYW4gYmUgcGFzc2VkIGluLiAgSWYgeW91IHdhbnQgdG8gcmVtb3ZlXG4gICAqIGEgYnVpbHQtaW4gY29udmVydGVyLCBwYXNzIGEgY29udmVydGVyIGluIHdob3NlIHZhbHVlIGlzICdudWxsJyBpbnN0ZWFkXG4gICAqIG9mIGEgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb252ZXJ0ZXJzIC0ga2V5cyBpbiB0aGUgb2JqZWN0IGFyZSBhIHRhZyBudW1iZXIsIHRoZSB2YWx1ZVxuICAgKiAgIGlzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0aGUgZGVjb2RlZCBDQk9SIGFuZCByZXR1cm5zIGEgSmF2YVNjcmlwdCB2YWx1ZVxuICAgKiAgIG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlLiAgVGhyb3cgYW4gZXhjZXB0aW9uIGluIHRoZSBmdW5jdGlvbiBvbiBlcnJvcnMuXG4gICAqIEByZXR1cm5zIHthbnl9IC0gdGhlIGNvbnZlcnRlZCBpdGVtXG4gICAqL1xuICBjb252ZXJ0IChjb252ZXJ0ZXJzKSB7XG4gICAgdmFyIGVyLCBmXG4gICAgZiA9IGNvbnZlcnRlcnMgIT0gbnVsbCA/IGNvbnZlcnRlcnNbdGhpcy50YWddIDogdW5kZWZpbmVkXG4gICAgaWYgKHR5cGVvZiBmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmID0gVGFnZ2VkWydfdGFnJyArIHRoaXMudGFnXVxuICAgICAgaWYgKHR5cGVvZiBmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZi5jYWxsKFRhZ2dlZCwgdGhpcy52YWx1ZSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZXIgPSBlcnJvclxuICAgICAgdGhpcy5lcnIgPSBlclxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUYWdnZWRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/borc/src/tagged.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/borc/src/utils.js":
/*!********************************************!*\
  !*** ../../node_modules/borc/src/utils.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\")\nconst Bignumber = (__webpack_require__(/*! bignumber.js */ \"(ssr)/../../node_modules/bignumber.js/bignumber.js\").BigNumber)\n\nconst constants = __webpack_require__(/*! ./constants */ \"(ssr)/../../node_modules/borc/src/constants.js\")\nconst SHIFT32 = constants.SHIFT32\nconst SHIFT16 = constants.SHIFT16\nconst MAX_SAFE_HIGH = 0x1fffff\n\nexports.parseHalf = function parseHalf (buf) {\n  var exp, mant, sign\n  sign = buf[0] & 0x80 ? -1 : 1\n  exp = (buf[0] & 0x7C) >> 2\n  mant = ((buf[0] & 0x03) << 8) | buf[1]\n  if (!exp) {\n    return sign * 5.9604644775390625e-8 * mant\n  } else if (exp === 0x1f) {\n    return sign * (mant ? 0 / 0 : 2e308)\n  } else {\n    return sign * Math.pow(2, exp - 25) * (1024 + mant)\n  }\n}\n\nfunction toHex (n) {\n  if (n < 16) {\n    return '0' + n.toString(16)\n  }\n\n  return n.toString(16)\n}\n\nexports.arrayBufferToBignumber = function (buf) {\n  const len = buf.byteLength\n  let res = ''\n  for (let i = 0; i < len; i++) {\n    res += toHex(buf[i])\n  }\n\n  return new Bignumber(res, 16)\n}\n\n// convert an Object into a Map\nexports.buildMap = (obj) => {\n  const res = new Map()\n  const keys = Object.keys(obj)\n  const length = keys.length\n  for (let i = 0; i < length; i++) {\n    res.set(keys[i], obj[keys[i]])\n  }\n  return res\n}\n\nexports.buildInt32 = (f, g) => {\n  return f * SHIFT16 + g\n}\n\nexports.buildInt64 = (f1, f2, g1, g2) => {\n  const f = exports.buildInt32(f1, f2)\n  const g = exports.buildInt32(g1, g2)\n\n  if (f > MAX_SAFE_HIGH) {\n    return new Bignumber(f).times(SHIFT32).plus(g)\n  } else {\n    return (f * SHIFT32) + g\n  }\n}\n\nexports.writeHalf = function writeHalf (buf, half) {\n  // assume 0, -0, NaN, Infinity, and -Infinity have already been caught\n\n  // HACK: everyone settle in.  This isn't going to be pretty.\n  // Translate cn-cbor's C code (from Carsten Borman):\n\n  // uint32_t be32;\n  // uint16_t be16, u16;\n  // union {\n  //   float f;\n  //   uint32_t u;\n  // } u32;\n  // u32.f = float_val;\n\n  const u32 = Buffer.allocUnsafe(4)\n  u32.writeFloatBE(half, 0)\n  const u = u32.readUInt32BE(0)\n\n  // if ((u32.u & 0x1FFF) == 0) { /* worth trying half */\n\n  // hildjj: If the lower 13 bits are 0, we won't lose anything in the conversion\n  if ((u & 0x1FFF) !== 0) {\n    return false\n  }\n\n  //   int s16 = (u32.u >> 16) & 0x8000;\n  //   int exp = (u32.u >> 23) & 0xff;\n  //   int mant = u32.u & 0x7fffff;\n\n  var s16 = (u >> 16) & 0x8000 // top bit is sign\n  const exp = (u >> 23) & 0xff // then 5 bits of exponent\n  const mant = u & 0x7fffff\n\n  //   if (exp == 0 && mant == 0)\n  //     ;              /* 0.0, -0.0 */\n\n  // hildjj: zeros already handled.  Assert if you don't believe me.\n\n  //   else if (exp >= 113 && exp <= 142) /* normalized */\n  //     s16 += ((exp - 112) << 10) + (mant >> 13);\n  if ((exp >= 113) && (exp <= 142)) {\n    s16 += ((exp - 112) << 10) + (mant >> 13)\n\n  //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */\n  //     if (mant & ((1 << (126 - exp)) - 1))\n  //       goto float32;         /* loss of precision */\n  //     s16 += ((mant + 0x800000) >> (126 - exp));\n  } else if ((exp >= 103) && (exp < 113)) {\n    if (mant & ((1 << (126 - exp)) - 1)) {\n      return false\n    }\n    s16 += ((mant + 0x800000) >> (126 - exp))\n\n    //   } else if (exp == 255 && mant == 0) { /* Inf */\n    //     s16 += 0x7c00;\n\n    // hildjj: Infinity already handled\n\n  //   } else\n  //     goto float32;           /* loss of range */\n  } else {\n    return false\n  }\n\n  //   ensure_writable(3);\n  //   u16 = s16;\n  //   be16 = hton16p((const uint8_t*)&u16);\n  buf.writeUInt16BE(s16, 0)\n  return true\n}\n\nexports.keySorter = function (a, b) {\n  var lenA = a[0].byteLength\n  var lenB = b[0].byteLength\n\n  if (lenA > lenB) {\n    return 1\n  }\n\n  if (lenB > lenA) {\n    return -1\n  }\n\n  return a[0].compare(b[0])\n}\n\n// Adapted from http://www.2ality.com/2012/03/signedzero.html\nexports.isNegativeZero = (x) => {\n  return x === 0 && (1 / x < 0)\n}\n\nexports.nextPowerOf2 = (n) => {\n  let count = 0\n  // First n in the below condition is for\n  // the case where n is 0\n  if (n && !(n & (n - 1))) {\n    return n\n  }\n\n  while (n !== 0) {\n    n >>= 1\n    count += 1\n  }\n\n  return 1 << count\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDbkMsa0JBQWtCLHlHQUFpQzs7QUFFbkQsa0JBQWtCLG1CQUFPLENBQUMsbUVBQWE7QUFDdkM7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxvQ0FBb0M7QUFDL0M7O0FBRUE7O0FBRUEsU0FBUztBQUNULGlDQUFpQztBQUNqQyxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbm9ib2R5MS9Xb3JrL3EzeC9zY2FmZm9sZC1pY3Avbm9kZV9tb2R1bGVzL2JvcmMvc3JjL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IEJpZ251bWJlciA9IHJlcXVpcmUoJ2JpZ251bWJlci5qcycpLkJpZ051bWJlclxuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBTSElGVDMyID0gY29uc3RhbnRzLlNISUZUMzJcbmNvbnN0IFNISUZUMTYgPSBjb25zdGFudHMuU0hJRlQxNlxuY29uc3QgTUFYX1NBRkVfSElHSCA9IDB4MWZmZmZmXG5cbmV4cG9ydHMucGFyc2VIYWxmID0gZnVuY3Rpb24gcGFyc2VIYWxmIChidWYpIHtcbiAgdmFyIGV4cCwgbWFudCwgc2lnblxuICBzaWduID0gYnVmWzBdICYgMHg4MCA/IC0xIDogMVxuICBleHAgPSAoYnVmWzBdICYgMHg3QykgPj4gMlxuICBtYW50ID0gKChidWZbMF0gJiAweDAzKSA8PCA4KSB8IGJ1ZlsxXVxuICBpZiAoIWV4cCkge1xuICAgIHJldHVybiBzaWduICogNS45NjA0NjQ0Nzc1MzkwNjI1ZS04ICogbWFudFxuICB9IGVsc2UgaWYgKGV4cCA9PT0gMHgxZikge1xuICAgIHJldHVybiBzaWduICogKG1hbnQgPyAwIC8gMCA6IDJlMzA4KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzaWduICogTWF0aC5wb3coMiwgZXhwIC0gMjUpICogKDEwMjQgKyBtYW50KVxuICB9XG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHtcbiAgICByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgfVxuXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5leHBvcnRzLmFycmF5QnVmZmVyVG9CaWdudW1iZXIgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5ieXRlTGVuZ3RoXG4gIGxldCByZXMgPSAnJ1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuXG4gIHJldHVybiBuZXcgQmlnbnVtYmVyKHJlcywgMTYpXG59XG5cbi8vIGNvbnZlcnQgYW4gT2JqZWN0IGludG8gYSBNYXBcbmV4cG9ydHMuYnVpbGRNYXAgPSAob2JqKSA9PiB7XG4gIGNvbnN0IHJlcyA9IG5ldyBNYXAoKVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKVxuICBjb25zdCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnNldChrZXlzW2ldLCBvYmpba2V5c1tpXV0pXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5leHBvcnRzLmJ1aWxkSW50MzIgPSAoZiwgZykgPT4ge1xuICByZXR1cm4gZiAqIFNISUZUMTYgKyBnXG59XG5cbmV4cG9ydHMuYnVpbGRJbnQ2NCA9IChmMSwgZjIsIGcxLCBnMikgPT4ge1xuICBjb25zdCBmID0gZXhwb3J0cy5idWlsZEludDMyKGYxLCBmMilcbiAgY29uc3QgZyA9IGV4cG9ydHMuYnVpbGRJbnQzMihnMSwgZzIpXG5cbiAgaWYgKGYgPiBNQVhfU0FGRV9ISUdIKSB7XG4gICAgcmV0dXJuIG5ldyBCaWdudW1iZXIoZikudGltZXMoU0hJRlQzMikucGx1cyhnKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZiAqIFNISUZUMzIpICsgZ1xuICB9XG59XG5cbmV4cG9ydHMud3JpdGVIYWxmID0gZnVuY3Rpb24gd3JpdGVIYWxmIChidWYsIGhhbGYpIHtcbiAgLy8gYXNzdW1lIDAsIC0wLCBOYU4sIEluZmluaXR5LCBhbmQgLUluZmluaXR5IGhhdmUgYWxyZWFkeSBiZWVuIGNhdWdodFxuXG4gIC8vIEhBQ0s6IGV2ZXJ5b25lIHNldHRsZSBpbi4gIFRoaXMgaXNuJ3QgZ29pbmcgdG8gYmUgcHJldHR5LlxuICAvLyBUcmFuc2xhdGUgY24tY2JvcidzIEMgY29kZSAoZnJvbSBDYXJzdGVuIEJvcm1hbik6XG5cbiAgLy8gdWludDMyX3QgYmUzMjtcbiAgLy8gdWludDE2X3QgYmUxNiwgdTE2O1xuICAvLyB1bmlvbiB7XG4gIC8vICAgZmxvYXQgZjtcbiAgLy8gICB1aW50MzJfdCB1O1xuICAvLyB9IHUzMjtcbiAgLy8gdTMyLmYgPSBmbG9hdF92YWw7XG5cbiAgY29uc3QgdTMyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQpXG4gIHUzMi53cml0ZUZsb2F0QkUoaGFsZiwgMClcbiAgY29uc3QgdSA9IHUzMi5yZWFkVUludDMyQkUoMClcblxuICAvLyBpZiAoKHUzMi51ICYgMHgxRkZGKSA9PSAwKSB7IC8qIHdvcnRoIHRyeWluZyBoYWxmICovXG5cbiAgLy8gaGlsZGpqOiBJZiB0aGUgbG93ZXIgMTMgYml0cyBhcmUgMCwgd2Ugd29uJ3QgbG9zZSBhbnl0aGluZyBpbiB0aGUgY29udmVyc2lvblxuICBpZiAoKHUgJiAweDFGRkYpICE9PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyAgIGludCBzMTYgPSAodTMyLnUgPj4gMTYpICYgMHg4MDAwO1xuICAvLyAgIGludCBleHAgPSAodTMyLnUgPj4gMjMpICYgMHhmZjtcbiAgLy8gICBpbnQgbWFudCA9IHUzMi51ICYgMHg3ZmZmZmY7XG5cbiAgdmFyIHMxNiA9ICh1ID4+IDE2KSAmIDB4ODAwMCAvLyB0b3AgYml0IGlzIHNpZ25cbiAgY29uc3QgZXhwID0gKHUgPj4gMjMpICYgMHhmZiAvLyB0aGVuIDUgYml0cyBvZiBleHBvbmVudFxuICBjb25zdCBtYW50ID0gdSAmIDB4N2ZmZmZmXG5cbiAgLy8gICBpZiAoZXhwID09IDAgJiYgbWFudCA9PSAwKVxuICAvLyAgICAgOyAgICAgICAgICAgICAgLyogMC4wLCAtMC4wICovXG5cbiAgLy8gaGlsZGpqOiB6ZXJvcyBhbHJlYWR5IGhhbmRsZWQuICBBc3NlcnQgaWYgeW91IGRvbid0IGJlbGlldmUgbWUuXG5cbiAgLy8gICBlbHNlIGlmIChleHAgPj0gMTEzICYmIGV4cCA8PSAxNDIpIC8qIG5vcm1hbGl6ZWQgKi9cbiAgLy8gICAgIHMxNiArPSAoKGV4cCAtIDExMikgPDwgMTApICsgKG1hbnQgPj4gMTMpO1xuICBpZiAoKGV4cCA+PSAxMTMpICYmIChleHAgPD0gMTQyKSkge1xuICAgIHMxNiArPSAoKGV4cCAtIDExMikgPDwgMTApICsgKG1hbnQgPj4gMTMpXG5cbiAgLy8gICBlbHNlIGlmIChleHAgPj0gMTAzICYmIGV4cCA8IDExMykgeyAvKiBkZW5vcm0sIGV4cDE2ID0gMCAqL1xuICAvLyAgICAgaWYgKG1hbnQgJiAoKDEgPDwgKDEyNiAtIGV4cCkpIC0gMSkpXG4gIC8vICAgICAgIGdvdG8gZmxvYXQzMjsgICAgICAgICAvKiBsb3NzIG9mIHByZWNpc2lvbiAqL1xuICAvLyAgICAgczE2ICs9ICgobWFudCArIDB4ODAwMDAwKSA+PiAoMTI2IC0gZXhwKSk7XG4gIH0gZWxzZSBpZiAoKGV4cCA+PSAxMDMpICYmIChleHAgPCAxMTMpKSB7XG4gICAgaWYgKG1hbnQgJiAoKDEgPDwgKDEyNiAtIGV4cCkpIC0gMSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBzMTYgKz0gKChtYW50ICsgMHg4MDAwMDApID4+ICgxMjYgLSBleHApKVxuXG4gICAgLy8gICB9IGVsc2UgaWYgKGV4cCA9PSAyNTUgJiYgbWFudCA9PSAwKSB7IC8qIEluZiAqL1xuICAgIC8vICAgICBzMTYgKz0gMHg3YzAwO1xuXG4gICAgLy8gaGlsZGpqOiBJbmZpbml0eSBhbHJlYWR5IGhhbmRsZWRcblxuICAvLyAgIH0gZWxzZVxuICAvLyAgICAgZ290byBmbG9hdDMyOyAgICAgICAgICAgLyogbG9zcyBvZiByYW5nZSAqL1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gICBlbnN1cmVfd3JpdGFibGUoMyk7XG4gIC8vICAgdTE2ID0gczE2O1xuICAvLyAgIGJlMTYgPSBodG9uMTZwKChjb25zdCB1aW50OF90KikmdTE2KTtcbiAgYnVmLndyaXRlVUludDE2QkUoczE2LCAwKVxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnRzLmtleVNvcnRlciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciBsZW5BID0gYVswXS5ieXRlTGVuZ3RoXG4gIHZhciBsZW5CID0gYlswXS5ieXRlTGVuZ3RoXG5cbiAgaWYgKGxlbkEgPiBsZW5CKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIGlmIChsZW5CID4gbGVuQSkge1xuICAgIHJldHVybiAtMVxuICB9XG5cbiAgcmV0dXJuIGFbMF0uY29tcGFyZShiWzBdKVxufVxuXG4vLyBBZGFwdGVkIGZyb20gaHR0cDovL3d3dy4yYWxpdHkuY29tLzIwMTIvMDMvc2lnbmVkemVyby5odG1sXG5leHBvcnRzLmlzTmVnYXRpdmVaZXJvID0gKHgpID0+IHtcbiAgcmV0dXJuIHggPT09IDAgJiYgKDEgLyB4IDwgMClcbn1cblxuZXhwb3J0cy5uZXh0UG93ZXJPZjIgPSAobikgPT4ge1xuICBsZXQgY291bnQgPSAwXG4gIC8vIEZpcnN0IG4gaW4gdGhlIGJlbG93IGNvbmRpdGlvbiBpcyBmb3JcbiAgLy8gdGhlIGNhc2Ugd2hlcmUgbiBpcyAwXG4gIGlmIChuICYmICEobiAmIChuIC0gMSkpKSB7XG4gICAgcmV0dXJuIG5cbiAgfVxuXG4gIHdoaWxlIChuICE9PSAwKSB7XG4gICAgbiA+Pj0gMVxuICAgIGNvdW50ICs9IDFcbiAgfVxuXG4gIHJldHVybiAxIDw8IGNvdW50XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/borc/src/utils.js\n");

/***/ })

};
;