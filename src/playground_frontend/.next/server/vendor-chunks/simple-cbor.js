"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/simple-cbor";
exports.ids = ["vendor-chunks/simple-cbor"];
exports.modules = {

/***/ "(ssr)/../../node_modules/simple-cbor/src/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/simple-cbor/src/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__export(__webpack_require__(/*! ./serializer */ \"(ssr)/../../node_modules/simple-cbor/src/serializer.js\"));\nconst value = __importStar(__webpack_require__(/*! ./value */ \"(ssr)/../../node_modules/simple-cbor/src/value.js\"));\nexports.value = value;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3NpbXBsZS1jYm9yL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFNBQVMsbUJBQU8sQ0FBQyw0RUFBYztBQUMvQiwyQkFBMkIsbUJBQU8sQ0FBQyxrRUFBUztBQUM1QyxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ub2JvZHkxL1dvcmsvcTN4L3NjYWZmb2xkLWljcC9ub2RlX21vZHVsZXMvc2ltcGxlLWNib3Ivc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NlcmlhbGl6ZXJcIikpO1xuY29uc3QgdmFsdWUgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdmFsdWVcIikpO1xuZXhwb3J0cy52YWx1ZSA9IHZhbHVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/simple-cbor/src/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/simple-cbor/src/serializer.js":
/*!********************************************************!*\
  !*** ../../node_modules/simple-cbor/src/serializer.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst cbor = __importStar(__webpack_require__(/*! ./value */ \"(ssr)/../../node_modules/simple-cbor/src/value.js\"));\nconst BufferClasses = [\n    ArrayBuffer,\n    Uint8Array,\n    Uint16Array,\n    Uint32Array,\n    Int8Array,\n    Int16Array,\n    Int32Array,\n    Float32Array,\n    Float64Array,\n];\nclass JsonDefaultCborEncoder {\n    // @param _serializer The CBOR Serializer to use.\n    // @param _stable Whether or not keys from objects should be sorted (stable). This is\n    //     particularly useful when testing encodings between JSON objects.\n    constructor(_serializer, _stable = false) {\n        this._serializer = _serializer;\n        this._stable = _stable;\n        this.name = \"jsonDefault\";\n        this.priority = -100;\n    }\n    match(value) {\n        return [\"undefined\", \"boolean\", \"number\", \"string\", \"object\"].indexOf(typeof value) != -1;\n    }\n    encode(value) {\n        switch (typeof value) {\n            case \"undefined\":\n                return cbor.undefined_();\n            case \"boolean\":\n                return cbor.bool(value);\n            case \"number\":\n                if (Math.floor(value) === value) {\n                    return cbor.number(value);\n                }\n                else {\n                    return cbor.doubleFloat(value);\n                }\n            case \"string\":\n                return cbor.string(value);\n            case \"object\":\n                if (value === null) {\n                    return cbor.null_();\n                }\n                else if (Array.isArray(value)) {\n                    return cbor.array(value.map((x) => this._serializer.serializeValue(x)));\n                }\n                else if (BufferClasses.find((x) => value instanceof x)) {\n                    return cbor.bytes(value.buffer);\n                }\n                else if (Object.getOwnPropertyNames(value).indexOf(\"toJSON\") !== -1) {\n                    return this.encode(value.toJSON());\n                }\n                else if (value instanceof Map) {\n                    const m = new Map();\n                    for (const [key, item] of value.entries()) {\n                        m.set(key, this._serializer.serializeValue(item));\n                    }\n                    return cbor.map(m, this._stable);\n                }\n                else {\n                    const m = new Map();\n                    for (const [key, item] of Object.entries(value)) {\n                        m.set(key, this._serializer.serializeValue(item));\n                    }\n                    return cbor.map(m, this._stable);\n                }\n            default:\n                throw new Error(\"Invalid value.\");\n        }\n    }\n}\nexports.JsonDefaultCborEncoder = JsonDefaultCborEncoder;\nclass ToCborEncoder {\n    constructor() {\n        this.name = \"cborEncoder\";\n        this.priority = -90;\n    }\n    match(value) {\n        return typeof value == \"object\" && typeof value[\"toCBOR\"] == \"function\";\n    }\n    encode(value) {\n        return value.toCBOR();\n    }\n}\nexports.ToCborEncoder = ToCborEncoder;\nclass CborSerializer {\n    constructor() {\n        this._encoders = new Set();\n    }\n    static withDefaultEncoders(stable = false) {\n        const s = new this();\n        s.addEncoder(new JsonDefaultCborEncoder(s, stable));\n        s.addEncoder(new ToCborEncoder());\n        return s;\n    }\n    removeEncoder(name) {\n        // Has to make an extra call to values() to ensure it doesn't break on iteration.\n        for (const encoder of this._encoders.values()) {\n            if (encoder.name == name) {\n                this._encoders.delete(encoder);\n            }\n        }\n    }\n    addEncoder(encoder) {\n        this._encoders.add(encoder);\n    }\n    getEncoderFor(value) {\n        let chosenEncoder = null;\n        for (const encoder of this._encoders) {\n            if (!chosenEncoder || encoder.priority > chosenEncoder.priority) {\n                if (encoder.match(value)) {\n                    chosenEncoder = encoder;\n                }\n            }\n        }\n        if (chosenEncoder === null) {\n            throw new Error(\"Could not find an encoder for value.\");\n        }\n        return chosenEncoder;\n    }\n    serializeValue(value) {\n        return this.getEncoderFor(value).encode(value);\n    }\n    serialize(value) {\n        return this.serializeValue(value);\n    }\n}\nexports.CborSerializer = CborSerializer;\nclass SelfDescribeCborSerializer extends CborSerializer {\n    serialize(value) {\n        return cbor.raw(new Uint8Array([\n            // Self describe CBOR.\n            ...new Uint8Array([0xd9, 0xd9, 0xf7]),\n            ...new Uint8Array(super.serializeValue(value)),\n        ]));\n    }\n}\nexports.SelfDescribeCborSerializer = SelfDescribeCborSerializer;\n//# sourceMappingURL=serializer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3NpbXBsZS1jYm9yL3NyYy9zZXJpYWxpemVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLG1CQUFPLENBQUMsa0VBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyIsInNvdXJjZXMiOlsiL1VzZXJzL25vYm9keTEvV29yay9xM3gvc2NhZmZvbGQtaWNwL25vZGVfbW9kdWxlcy9zaW1wbGUtY2Jvci9zcmMvc2VyaWFsaXplci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNib3IgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdmFsdWVcIikpO1xuY29uc3QgQnVmZmVyQ2xhc3NlcyA9IFtcbiAgICBBcnJheUJ1ZmZlcixcbiAgICBVaW50OEFycmF5LFxuICAgIFVpbnQxNkFycmF5LFxuICAgIFVpbnQzMkFycmF5LFxuICAgIEludDhBcnJheSxcbiAgICBJbnQxNkFycmF5LFxuICAgIEludDMyQXJyYXksXG4gICAgRmxvYXQzMkFycmF5LFxuICAgIEZsb2F0NjRBcnJheSxcbl07XG5jbGFzcyBKc29uRGVmYXVsdENib3JFbmNvZGVyIHtcbiAgICAvLyBAcGFyYW0gX3NlcmlhbGl6ZXIgVGhlIENCT1IgU2VyaWFsaXplciB0byB1c2UuXG4gICAgLy8gQHBhcmFtIF9zdGFibGUgV2hldGhlciBvciBub3Qga2V5cyBmcm9tIG9iamVjdHMgc2hvdWxkIGJlIHNvcnRlZCAoc3RhYmxlKS4gVGhpcyBpc1xuICAgIC8vICAgICBwYXJ0aWN1bGFybHkgdXNlZnVsIHdoZW4gdGVzdGluZyBlbmNvZGluZ3MgYmV0d2VlbiBKU09OIG9iamVjdHMuXG4gICAgY29uc3RydWN0b3IoX3NlcmlhbGl6ZXIsIF9zdGFibGUgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLl9zZXJpYWxpemVyID0gX3NlcmlhbGl6ZXI7XG4gICAgICAgIHRoaXMuX3N0YWJsZSA9IF9zdGFibGU7XG4gICAgICAgIHRoaXMubmFtZSA9IFwianNvbkRlZmF1bHRcIjtcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IC0xMDA7XG4gICAgfVxuICAgIG1hdGNoKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbXCJ1bmRlZmluZWRcIiwgXCJib29sZWFuXCIsIFwibnVtYmVyXCIsIFwic3RyaW5nXCIsIFwib2JqZWN0XCJdLmluZGV4T2YodHlwZW9mIHZhbHVlKSAhPSAtMTtcbiAgICB9XG4gICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNib3IudW5kZWZpbmVkXygpO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci5ib29sKHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYm9yLm51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci5kb3VibGVGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBjYm9yLnN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYm9yLm51bGxfKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYm9yLmFycmF5KHZhbHVlLm1hcCgoeCkgPT4gdGhpcy5fc2VyaWFsaXplci5zZXJpYWxpemVWYWx1ZSh4KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChCdWZmZXJDbGFzc2VzLmZpbmQoKHgpID0+IHZhbHVlIGluc3RhbmNlb2YgeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNib3IuYnl0ZXModmFsdWUuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLmluZGV4T2YoXCJ0b0pTT05cIikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZSh2YWx1ZS50b0pTT04oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgaXRlbV0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnNldChrZXksIHRoaXMuX3NlcmlhbGl6ZXIuc2VyaWFsaXplVmFsdWUoaXRlbSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYm9yLm1hcChtLCB0aGlzLl9zdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCBpdGVtXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uc2V0KGtleSwgdGhpcy5fc2VyaWFsaXplci5zZXJpYWxpemVWYWx1ZShpdGVtKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNib3IubWFwKG0sIHRoaXMuX3N0YWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuSnNvbkRlZmF1bHRDYm9yRW5jb2RlciA9IEpzb25EZWZhdWx0Q2JvckVuY29kZXI7XG5jbGFzcyBUb0Nib3JFbmNvZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJjYm9yRW5jb2RlclwiO1xuICAgICAgICB0aGlzLnByaW9yaXR5ID0gLTkwO1xuICAgIH1cbiAgICBtYXRjaCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlW1widG9DQk9SXCJdID09IFwiZnVuY3Rpb25cIjtcbiAgICB9XG4gICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0NCT1IoKTtcbiAgICB9XG59XG5leHBvcnRzLlRvQ2JvckVuY29kZXIgPSBUb0Nib3JFbmNvZGVyO1xuY2xhc3MgQ2JvclNlcmlhbGl6ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9lbmNvZGVycyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgc3RhdGljIHdpdGhEZWZhdWx0RW5jb2RlcnMoc3RhYmxlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgcyA9IG5ldyB0aGlzKCk7XG4gICAgICAgIHMuYWRkRW5jb2RlcihuZXcgSnNvbkRlZmF1bHRDYm9yRW5jb2RlcihzLCBzdGFibGUpKTtcbiAgICAgICAgcy5hZGRFbmNvZGVyKG5ldyBUb0Nib3JFbmNvZGVyKCkpO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgcmVtb3ZlRW5jb2RlcihuYW1lKSB7XG4gICAgICAgIC8vIEhhcyB0byBtYWtlIGFuIGV4dHJhIGNhbGwgdG8gdmFsdWVzKCkgdG8gZW5zdXJlIGl0IGRvZXNuJ3QgYnJlYWsgb24gaXRlcmF0aW9uLlxuICAgICAgICBmb3IgKGNvbnN0IGVuY29kZXIgb2YgdGhpcy5fZW5jb2RlcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChlbmNvZGVyLm5hbWUgPT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuY29kZXJzLmRlbGV0ZShlbmNvZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRFbmNvZGVyKGVuY29kZXIpIHtcbiAgICAgICAgdGhpcy5fZW5jb2RlcnMuYWRkKGVuY29kZXIpO1xuICAgIH1cbiAgICBnZXRFbmNvZGVyRm9yKHZhbHVlKSB7XG4gICAgICAgIGxldCBjaG9zZW5FbmNvZGVyID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBlbmNvZGVyIG9mIHRoaXMuX2VuY29kZXJzKSB7XG4gICAgICAgICAgICBpZiAoIWNob3NlbkVuY29kZXIgfHwgZW5jb2Rlci5wcmlvcml0eSA+IGNob3NlbkVuY29kZXIucHJpb3JpdHkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2Rlci5tYXRjaCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hvc2VuRW5jb2RlciA9IGVuY29kZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaG9zZW5FbmNvZGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBhbiBlbmNvZGVyIGZvciB2YWx1ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNob3NlbkVuY29kZXI7XG4gICAgfVxuICAgIHNlcmlhbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVuY29kZXJGb3IodmFsdWUpLmVuY29kZSh2YWx1ZSk7XG4gICAgfVxuICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5DYm9yU2VyaWFsaXplciA9IENib3JTZXJpYWxpemVyO1xuY2xhc3MgU2VsZkRlc2NyaWJlQ2JvclNlcmlhbGl6ZXIgZXh0ZW5kcyBDYm9yU2VyaWFsaXplciB7XG4gICAgc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYm9yLnJhdyhuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAvLyBTZWxmIGRlc2NyaWJlIENCT1IuXG4gICAgICAgICAgICAuLi5uZXcgVWludDhBcnJheShbMHhkOSwgMHhkOSwgMHhmN10pLFxuICAgICAgICAgICAgLi4ubmV3IFVpbnQ4QXJyYXkoc3VwZXIuc2VyaWFsaXplVmFsdWUodmFsdWUpKSxcbiAgICAgICAgXSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VsZkRlc2NyaWJlQ2JvclNlcmlhbGl6ZXIgPSBTZWxmRGVzY3JpYmVDYm9yU2VyaWFsaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcmlhbGl6ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/simple-cbor/src/serializer.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/simple-cbor/src/value.js":
/*!***************************************************!*\
  !*** ../../node_modules/simple-cbor/src/value.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst MAX_U64_NUMBER = 0x20000000000000;\nfunction _concat(a, ...args) {\n    const newBuffer = new Uint8Array(a.byteLength + args.reduce((acc, b) => acc + b.byteLength, 0));\n    newBuffer.set(new Uint8Array(a), 0);\n    let i = a.byteLength;\n    for (const b of args) {\n        newBuffer.set(new Uint8Array(b), i);\n        i += b.byteLength;\n    }\n    return newBuffer.buffer;\n}\nfunction _serializeValue(major, minor, value) {\n    // Remove everything that's not an hexadecimal character. These are not\n    // considered errors since the value was already validated and they might\n    // be number decimals or sign.\n    value = value.replace(/[^0-9a-fA-F]/g, \"\");\n    // Create the buffer from the value with left padding with 0.\n    const length = 2 ** (minor - 24 /* Int8 */);\n    value = value.slice(-length * 2).padStart(length * 2, \"0\");\n    const bytes = [(major << 5) + minor].concat(value.match(/../g).map((byte) => parseInt(byte, 16)));\n    return new Uint8Array(bytes).buffer;\n}\nfunction _serializeNumber(major, value) {\n    if (value < 24) {\n        return new Uint8Array([(major << 5) + value]).buffer;\n    }\n    else {\n        const minor = value <= 0xff\n            ? 24 /* Int8 */\n            : value <= 0xffff\n                ? 25 /* Int16 */\n                : value <= 0xffffffff\n                    ? 26 /* Int32 */\n                    : 27 /* Int64 */;\n        return _serializeValue(major, minor, value.toString(16));\n    }\n}\nfunction _serializeString(str) {\n    const utf8 = [];\n    for (let i = 0; i < str.length; i++) {\n        let charcode = str.charCodeAt(i);\n        if (charcode < 0x80) {\n            utf8.push(charcode);\n        }\n        else if (charcode < 0x800) {\n            utf8.push(0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f));\n        }\n        else if (charcode < 0xd800 || charcode >= 0xe000) {\n            utf8.push(0xe0 | (charcode >> 12), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));\n        }\n        else {\n            // Surrogate pair\n            i++;\n            charcode = ((charcode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff);\n            utf8.push(0xf0 | (charcode >> 18), 0x80 | ((charcode >> 12) & 0x3f), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));\n        }\n    }\n    return _concat(new Uint8Array(_serializeNumber(3 /* TextString */, str.length)), new Uint8Array(utf8));\n}\n/**\n * Tag a value.\n */\nfunction tagged(tag, value) {\n    if (tag == 0xd9d9f7) {\n        return _concat(new Uint8Array([0xd9, 0xd9, 0xf7]), value);\n    }\n    if (tag < 24) {\n        return _concat(new Uint8Array([(6 /* Tag */ << 5) + tag]), value);\n    }\n    else {\n        const minor = tag <= 0xff\n            ? 24 /* Int8 */\n            : tag <= 0xffff\n                ? 25 /* Int16 */\n                : tag <= 0xffffffff\n                    ? 26 /* Int32 */\n                    : 27 /* Int64 */;\n        const length = 2 ** (minor - 24 /* Int8 */);\n        const value = tag\n            .toString(16)\n            .slice(-length * 2)\n            .padStart(length * 2, \"0\");\n        const bytes = [(6 /* Tag */ << 5) + minor].concat(value.match(/../g).map((byte) => parseInt(byte, 16)));\n        return new Uint8Array(bytes).buffer;\n    }\n}\nexports.tagged = tagged;\n/**\n * Set the raw bytes contained by this value. This should only be used with another\n * CborValue, or if you are implementing extensions to CBOR.\n * @param bytes A buffer containing the value.\n */\nfunction raw(bytes) {\n    return new Uint8Array(bytes).buffer;\n}\nexports.raw = raw;\n/**\n * Encode a number that is between [0, 23].\n * @param n\n */\nfunction uSmall(n) {\n    if (isNaN(n)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    n = Math.min(Math.max(0, n), 23); // Clamp it.\n    const bytes = [(0 /* UnsignedInteger */ << 5) + n];\n    return new Uint8Array(bytes).buffer;\n}\nexports.uSmall = uSmall;\nfunction u8(u8, radix) {\n    // Force u8 into a number, and validate it.\n    u8 = parseInt(\"\" + u8, radix);\n    if (isNaN(u8)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u8 = Math.min(Math.max(0, u8), 0xff); // Clamp it.\n    u8 = u8.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 24 /* Int8 */, u8);\n}\nexports.u8 = u8;\nfunction u16(u16, radix) {\n    // Force u16 into a number, and validate it.\n    u16 = parseInt(\"\" + u16, radix);\n    if (isNaN(u16)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u16 = Math.min(Math.max(0, u16), 0xffff); // Clamp it.\n    u16 = u16.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 25 /* Int16 */, u16);\n}\nexports.u16 = u16;\nfunction u32(u32, radix) {\n    // Force u32 into a number, and validate it.\n    u32 = parseInt(\"\" + u32, radix);\n    if (isNaN(u32)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u32 = Math.min(Math.max(0, u32), 0xffffffff); // Clamp it.\n    u32 = u32.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 26 /* Int32 */, u32);\n}\nexports.u32 = u32;\nfunction u64(u64, radix) {\n    // Special consideration for numbers that might be larger than expected.\n    if (typeof u64 == \"string\" && radix == 16) {\n        // This is the only case where we guarantee we'll encode the number directly.\n        // Validate it's all hexadecimal first.\n        if (u64.match(/[^0-9a-fA-F]/)) {\n            throw new RangeError(\"Invalid number.\");\n        }\n        return _serializeValue(0 /* UnsignedInteger */, 27 /* Int64 */, u64);\n    }\n    // Force u64 into a number, and validate it.\n    u64 = parseInt(\"\" + u64, radix);\n    if (isNaN(u64)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u64 = Math.min(Math.max(0, u64), MAX_U64_NUMBER); // Clamp it to actual limit.\n    u64 = u64.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 27 /* Int64 */, u64);\n}\nexports.u64 = u64;\n/**\n * Encode a negative number that is between [-24, -1].\n */\nfunction iSmall(n) {\n    if (isNaN(n)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    if (n === 0) {\n        return uSmall(0);\n    }\n    // Negative n, clamped to [1, 24], minus 1 (there's no negative 0).\n    n = Math.min(Math.max(0, -n), 24) - 1;\n    const bytes = [(1 /* SignedInteger */ << 5) + n];\n    return new Uint8Array(bytes).buffer;\n}\nexports.iSmall = iSmall;\nfunction i8(i8, radix) {\n    // Force i8 into a number, and validate it.\n    i8 = parseInt(\"\" + i8, radix);\n    if (isNaN(i8)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    // Negative n, clamped, minus 1 (there's no negative 0).\n    i8 = Math.min(Math.max(0, -i8 - 1), 0xff);\n    i8 = i8.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 24 /* Int8 */, i8);\n}\nexports.i8 = i8;\nfunction i16(i16, radix) {\n    // Force i16 into a number, and validate it.\n    i16 = parseInt(\"\" + i16, radix);\n    if (isNaN(i16)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    // Negative n, clamped, minus 1 (there's no negative 0).\n    i16 = Math.min(Math.max(0, -i16 - 1), 0xffff);\n    i16 = i16.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 25 /* Int16 */, i16);\n}\nexports.i16 = i16;\nfunction i32(i32, radix) {\n    // Force i32 into a number, and validate it.\n    i32 = parseInt(\"\" + i32, radix);\n    if (isNaN(i32)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    // Negative n, clamped, minus 1 (there's no negative 0).\n    i32 = Math.min(Math.max(0, -i32 - 1), 0xffffffff);\n    i32 = i32.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 26 /* Int32 */, i32);\n}\nexports.i32 = i32;\nfunction i64(i64, radix) {\n    // Special consideration for numbers that might be larger than expected.\n    if (typeof i64 == \"string\" && radix == 16) {\n        if (i64.startsWith(\"-\")) {\n            i64 = i64.slice(1);\n        }\n        else {\n            // Clamp it.\n            i64 = \"0\";\n        }\n        // This is the only case where we guarantee we'll encode the number directly.\n        // Validate it's all hexadecimal first.\n        if (i64.match(/[^0-9a-fA-F]/) || i64.length > 16) {\n            throw new RangeError(\"Invalid number.\");\n        }\n        // We need to do -1 to the number.\n        let done = false;\n        let newI64 = i64.split(\"\").reduceRight((acc, x) => {\n            if (done) {\n                return x + acc;\n            }\n            let n = parseInt(x, 16) - 1;\n            if (n >= 0) {\n                done = true;\n                return n.toString(16) + acc;\n            }\n            else {\n                return \"f\" + acc;\n            }\n        }, \"\");\n        if (!done) {\n            // This number was 0.\n            return u64(0);\n        }\n        return _serializeValue(1 /* SignedInteger */, 27 /* Int64 */, newI64);\n    }\n    // Force i64 into a number, and validate it.\n    i64 = parseInt(\"\" + i64, radix);\n    if (isNaN(i64)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    i64 = Math.min(Math.max(0, -i64 - 1), 0x20000000000000); // Clamp it to actual.\n    i64 = i64.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 27 /* Int64 */, i64);\n}\nexports.i64 = i64;\n/**\n * Encode a number using the smallest amount of bytes, by calling the methods\n * above. e.g. If the number fits in a u8, it will use that.\n */\nfunction number(n) {\n    if (n >= 0) {\n        if (n < 24) {\n            return uSmall(n);\n        }\n        else if (n <= 0xff) {\n            return u8(n);\n        }\n        else if (n <= 0xffff) {\n            return u16(n);\n        }\n        else if (n <= 0xffffffff) {\n            return u32(n);\n        }\n        else {\n            return u64(n);\n        }\n    }\n    else {\n        if (n >= -24) {\n            return iSmall(n);\n        }\n        else if (n >= -0xff) {\n            return i8(n);\n        }\n        else if (n >= -0xffff) {\n            return i16(n);\n        }\n        else if (n >= -0xffffffff) {\n            return i32(n);\n        }\n        else {\n            return i64(n);\n        }\n    }\n}\nexports.number = number;\n/**\n * Encode a byte array. This is different than the `raw()` method.\n */\nfunction bytes(bytes) {\n    return _concat(_serializeNumber(2 /* ByteString */, bytes.byteLength), bytes);\n}\nexports.bytes = bytes;\n/**\n * Encode a JavaScript string.\n */\nfunction string(str) {\n    return _serializeString(str);\n}\nexports.string = string;\n/**\n * Encode an array of cbor values.\n */\nfunction array(items) {\n    return _concat(_serializeNumber(4 /* Array */, items.length), ...items);\n}\nexports.array = array;\n/**\n * Encode a map of key-value pairs. The keys are string, and the values are CBOR\n * encoded.\n */\nfunction map(items, stable = false) {\n    if (!(items instanceof Map)) {\n        items = new Map(Object.entries(items));\n    }\n    let entries = Array.from(items.entries());\n    if (stable) {\n        entries = entries.sort(([keyA], [keyB]) => keyA.localeCompare(keyB));\n    }\n    return _concat(_serializeNumber(5 /* Map */, items.size), ...entries.map(([k, v]) => _concat(_serializeString(k), v)));\n}\nexports.map = map;\n/**\n * Encode a single (32 bits) precision floating point number.\n */\nfunction singleFloat(f) {\n    const single = new Float32Array([f]);\n    return _concat(new Uint8Array([(7 /* SimpleValue */ << 5) + 26]), new Uint8Array(single.buffer));\n}\nexports.singleFloat = singleFloat;\n/**\n * Encode a double (64 bits) precision floating point number.\n */\nfunction doubleFloat(f) {\n    const single = new Float64Array([f]);\n    return _concat(new Uint8Array([(7 /* SimpleValue */ << 5) + 27]), new Uint8Array(single.buffer));\n}\nexports.doubleFloat = doubleFloat;\nfunction bool(v) {\n    return v ? true_() : false_();\n}\nexports.bool = bool;\n/**\n * Encode the boolean true.\n */\nfunction true_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 21]));\n}\nexports.true_ = true_;\n/**\n * Encode the boolean false.\n */\nfunction false_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 20]));\n}\nexports.false_ = false_;\n/**\n * Encode the constant null.\n */\nfunction null_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 22]));\n}\nexports.null_ = null_;\n/**\n * Encode the constant undefined.\n */\nfunction undefined_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 23]));\n}\nexports.undefined_ = undefined_;\n//# sourceMappingURL=value.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3NpbXBsZS1jYm9yL3NyYy92YWx1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ub2JvZHkxL1dvcmsvcTN4L3NjYWZmb2xkLWljcC9ub2RlX21vZHVsZXMvc2ltcGxlLWNib3Ivc3JjL3ZhbHVlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTUFYX1U2NF9OVU1CRVIgPSAweDIwMDAwMDAwMDAwMDAwO1xuZnVuY3Rpb24gX2NvbmNhdChhLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgbmV3QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYS5ieXRlTGVuZ3RoICsgYXJncy5yZWR1Y2UoKGFjYywgYikgPT4gYWNjICsgYi5ieXRlTGVuZ3RoLCAwKSk7XG4gICAgbmV3QnVmZmVyLnNldChuZXcgVWludDhBcnJheShhKSwgMCk7XG4gICAgbGV0IGkgPSBhLmJ5dGVMZW5ndGg7XG4gICAgZm9yIChjb25zdCBiIG9mIGFyZ3MpIHtcbiAgICAgICAgbmV3QnVmZmVyLnNldChuZXcgVWludDhBcnJheShiKSwgaSk7XG4gICAgICAgIGkgKz0gYi5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QnVmZmVyLmJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVWYWx1ZShtYWpvciwgbWlub3IsIHZhbHVlKSB7XG4gICAgLy8gUmVtb3ZlIGV2ZXJ5dGhpbmcgdGhhdCdzIG5vdCBhbiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIuIFRoZXNlIGFyZSBub3RcbiAgICAvLyBjb25zaWRlcmVkIGVycm9ycyBzaW5jZSB0aGUgdmFsdWUgd2FzIGFscmVhZHkgdmFsaWRhdGVkIGFuZCB0aGV5IG1pZ2h0XG4gICAgLy8gYmUgbnVtYmVyIGRlY2ltYWxzIG9yIHNpZ24uXG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXjAtOWEtZkEtRl0vZywgXCJcIik7XG4gICAgLy8gQ3JlYXRlIHRoZSBidWZmZXIgZnJvbSB0aGUgdmFsdWUgd2l0aCBsZWZ0IHBhZGRpbmcgd2l0aCAwLlxuICAgIGNvbnN0IGxlbmd0aCA9IDIgKiogKG1pbm9yIC0gMjQgLyogSW50OCAqLyk7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgtbGVuZ3RoICogMikucGFkU3RhcnQobGVuZ3RoICogMiwgXCIwXCIpO1xuICAgIGNvbnN0IGJ5dGVzID0gWyhtYWpvciA8PCA1KSArIG1pbm9yXS5jb25jYXQodmFsdWUubWF0Y2goLy4uL2cpLm1hcCgoYnl0ZSkgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpKSk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKS5idWZmZXI7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplTnVtYmVyKG1ham9yLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA8IDI0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbKG1ham9yIDw8IDUpICsgdmFsdWVdKS5idWZmZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtaW5vciA9IHZhbHVlIDw9IDB4ZmZcbiAgICAgICAgICAgID8gMjQgLyogSW50OCAqL1xuICAgICAgICAgICAgOiB2YWx1ZSA8PSAweGZmZmZcbiAgICAgICAgICAgICAgICA/IDI1IC8qIEludDE2ICovXG4gICAgICAgICAgICAgICAgOiB2YWx1ZSA8PSAweGZmZmZmZmZmXG4gICAgICAgICAgICAgICAgICAgID8gMjYgLyogSW50MzIgKi9cbiAgICAgICAgICAgICAgICAgICAgOiAyNyAvKiBJbnQ2NCAqLztcbiAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVWYWx1ZShtYWpvciwgbWlub3IsIHZhbHVlLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZVN0cmluZyhzdHIpIHtcbiAgICBjb25zdCB1dGY4ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoYXJjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjaGFyY29kZSA8IDB4ODApIHtcbiAgICAgICAgICAgIHV0ZjgucHVzaChjaGFyY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhcmNvZGUgPCAweDgwMCkge1xuICAgICAgICAgICAgdXRmOC5wdXNoKDB4YzAgfCAoY2hhcmNvZGUgPj4gNiksIDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhcmNvZGUgPCAweGQ4MDAgfHwgY2hhcmNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICB1dGY4LnB1c2goMHhlMCB8IChjaGFyY29kZSA+PiAxMiksIDB4ODAgfCAoKGNoYXJjb2RlID4+IDYpICYgMHgzZiksIDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgcGFpclxuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY2hhcmNvZGUgPSAoKGNoYXJjb2RlICYgMHgzZmYpIDw8IDEwKSB8IChzdHIuY2hhckNvZGVBdChpKSAmIDB4M2ZmKTtcbiAgICAgICAgICAgIHV0ZjgucHVzaCgweGYwIHwgKGNoYXJjb2RlID4+IDE4KSwgMHg4MCB8ICgoY2hhcmNvZGUgPj4gMTIpICYgMHgzZiksIDB4ODAgfCAoKGNoYXJjb2RlID4+IDYpICYgMHgzZiksIDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9jb25jYXQobmV3IFVpbnQ4QXJyYXkoX3NlcmlhbGl6ZU51bWJlcigzIC8qIFRleHRTdHJpbmcgKi8sIHN0ci5sZW5ndGgpKSwgbmV3IFVpbnQ4QXJyYXkodXRmOCkpO1xufVxuLyoqXG4gKiBUYWcgYSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gdGFnZ2VkKHRhZywgdmFsdWUpIHtcbiAgICBpZiAodGFnID09IDB4ZDlkOWY3KSB7XG4gICAgICAgIHJldHVybiBfY29uY2F0KG5ldyBVaW50OEFycmF5KFsweGQ5LCAweGQ5LCAweGY3XSksIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHRhZyA8IDI0KSB7XG4gICAgICAgIHJldHVybiBfY29uY2F0KG5ldyBVaW50OEFycmF5KFsoNiAvKiBUYWcgKi8gPDwgNSkgKyB0YWddKSwgdmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWlub3IgPSB0YWcgPD0gMHhmZlxuICAgICAgICAgICAgPyAyNCAvKiBJbnQ4ICovXG4gICAgICAgICAgICA6IHRhZyA8PSAweGZmZmZcbiAgICAgICAgICAgICAgICA/IDI1IC8qIEludDE2ICovXG4gICAgICAgICAgICAgICAgOiB0YWcgPD0gMHhmZmZmZmZmZlxuICAgICAgICAgICAgICAgICAgICA/IDI2IC8qIEludDMyICovXG4gICAgICAgICAgICAgICAgICAgIDogMjcgLyogSW50NjQgKi87XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IDIgKiogKG1pbm9yIC0gMjQgLyogSW50OCAqLyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGFnXG4gICAgICAgICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAuc2xpY2UoLWxlbmd0aCAqIDIpXG4gICAgICAgICAgICAucGFkU3RhcnQobGVuZ3RoICogMiwgXCIwXCIpO1xuICAgICAgICBjb25zdCBieXRlcyA9IFsoNiAvKiBUYWcgKi8gPDwgNSkgKyBtaW5vcl0uY29uY2F0KHZhbHVlLm1hdGNoKC8uLi9nKS5tYXAoKGJ5dGUpID0+IHBhcnNlSW50KGJ5dGUsIDE2KSkpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLmJ1ZmZlcjtcbiAgICB9XG59XG5leHBvcnRzLnRhZ2dlZCA9IHRhZ2dlZDtcbi8qKlxuICogU2V0IHRoZSByYXcgYnl0ZXMgY29udGFpbmVkIGJ5IHRoaXMgdmFsdWUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aXRoIGFub3RoZXJcbiAqIENib3JWYWx1ZSwgb3IgaWYgeW91IGFyZSBpbXBsZW1lbnRpbmcgZXh0ZW5zaW9ucyB0byBDQk9SLlxuICogQHBhcmFtIGJ5dGVzIEEgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIHZhbHVlLlxuICovXG5mdW5jdGlvbiByYXcoYnl0ZXMpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLmJ1ZmZlcjtcbn1cbmV4cG9ydHMucmF3ID0gcmF3O1xuLyoqXG4gKiBFbmNvZGUgYSBudW1iZXIgdGhhdCBpcyBiZXR3ZWVuIFswLCAyM10uXG4gKiBAcGFyYW0gblxuICovXG5mdW5jdGlvbiB1U21hbGwobikge1xuICAgIGlmIChpc05hTihuKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICB9XG4gICAgbiA9IE1hdGgubWluKE1hdGgubWF4KDAsIG4pLCAyMyk7IC8vIENsYW1wIGl0LlxuICAgIGNvbnN0IGJ5dGVzID0gWygwIC8qIFVuc2lnbmVkSW50ZWdlciAqLyA8PCA1KSArIG5dO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcykuYnVmZmVyO1xufVxuZXhwb3J0cy51U21hbGwgPSB1U21hbGw7XG5mdW5jdGlvbiB1OCh1OCwgcmFkaXgpIHtcbiAgICAvLyBGb3JjZSB1OCBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgdTggPSBwYXJzZUludChcIlwiICsgdTgsIHJhZGl4KTtcbiAgICBpZiAoaXNOYU4odTgpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICB1OCA9IE1hdGgubWluKE1hdGgubWF4KDAsIHU4KSwgMHhmZik7IC8vIENsYW1wIGl0LlxuICAgIHU4ID0gdTgudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMCAvKiBVbnNpZ25lZEludGVnZXIgKi8sIDI0IC8qIEludDggKi8sIHU4KTtcbn1cbmV4cG9ydHMudTggPSB1ODtcbmZ1bmN0aW9uIHUxNih1MTYsIHJhZGl4KSB7XG4gICAgLy8gRm9yY2UgdTE2IGludG8gYSBudW1iZXIsIGFuZCB2YWxpZGF0ZSBpdC5cbiAgICB1MTYgPSBwYXJzZUludChcIlwiICsgdTE2LCByYWRpeCk7XG4gICAgaWYgKGlzTmFOKHUxNikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgfVxuICAgIHUxNiA9IE1hdGgubWluKE1hdGgubWF4KDAsIHUxNiksIDB4ZmZmZik7IC8vIENsYW1wIGl0LlxuICAgIHUxNiA9IHUxNi50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIF9zZXJpYWxpemVWYWx1ZSgwIC8qIFVuc2lnbmVkSW50ZWdlciAqLywgMjUgLyogSW50MTYgKi8sIHUxNik7XG59XG5leHBvcnRzLnUxNiA9IHUxNjtcbmZ1bmN0aW9uIHUzMih1MzIsIHJhZGl4KSB7XG4gICAgLy8gRm9yY2UgdTMyIGludG8gYSBudW1iZXIsIGFuZCB2YWxpZGF0ZSBpdC5cbiAgICB1MzIgPSBwYXJzZUludChcIlwiICsgdTMyLCByYWRpeCk7XG4gICAgaWYgKGlzTmFOKHUzMikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgfVxuICAgIHUzMiA9IE1hdGgubWluKE1hdGgubWF4KDAsIHUzMiksIDB4ZmZmZmZmZmYpOyAvLyBDbGFtcCBpdC5cbiAgICB1MzIgPSB1MzIudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMCAvKiBVbnNpZ25lZEludGVnZXIgKi8sIDI2IC8qIEludDMyICovLCB1MzIpO1xufVxuZXhwb3J0cy51MzIgPSB1MzI7XG5mdW5jdGlvbiB1NjQodTY0LCByYWRpeCkge1xuICAgIC8vIFNwZWNpYWwgY29uc2lkZXJhdGlvbiBmb3IgbnVtYmVycyB0aGF0IG1pZ2h0IGJlIGxhcmdlciB0aGFuIGV4cGVjdGVkLlxuICAgIGlmICh0eXBlb2YgdTY0ID09IFwic3RyaW5nXCIgJiYgcmFkaXggPT0gMTYpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgb25seSBjYXNlIHdoZXJlIHdlIGd1YXJhbnRlZSB3ZSdsbCBlbmNvZGUgdGhlIG51bWJlciBkaXJlY3RseS5cbiAgICAgICAgLy8gVmFsaWRhdGUgaXQncyBhbGwgaGV4YWRlY2ltYWwgZmlyc3QuXG4gICAgICAgIGlmICh1NjQubWF0Y2goL1teMC05YS1mQS1GXS8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZVZhbHVlKDAgLyogVW5zaWduZWRJbnRlZ2VyICovLCAyNyAvKiBJbnQ2NCAqLywgdTY0KTtcbiAgICB9XG4gICAgLy8gRm9yY2UgdTY0IGludG8gYSBudW1iZXIsIGFuZCB2YWxpZGF0ZSBpdC5cbiAgICB1NjQgPSBwYXJzZUludChcIlwiICsgdTY0LCByYWRpeCk7XG4gICAgaWYgKGlzTmFOKHU2NCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgfVxuICAgIHU2NCA9IE1hdGgubWluKE1hdGgubWF4KDAsIHU2NCksIE1BWF9VNjRfTlVNQkVSKTsgLy8gQ2xhbXAgaXQgdG8gYWN0dWFsIGxpbWl0LlxuICAgIHU2NCA9IHU2NC50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIF9zZXJpYWxpemVWYWx1ZSgwIC8qIFVuc2lnbmVkSW50ZWdlciAqLywgMjcgLyogSW50NjQgKi8sIHU2NCk7XG59XG5leHBvcnRzLnU2NCA9IHU2NDtcbi8qKlxuICogRW5jb2RlIGEgbmVnYXRpdmUgbnVtYmVyIHRoYXQgaXMgYmV0d2VlbiBbLTI0LCAtMV0uXG4gKi9cbmZ1bmN0aW9uIGlTbWFsbChuKSB7XG4gICAgaWYgKGlzTmFOKG4pKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdVNtYWxsKDApO1xuICAgIH1cbiAgICAvLyBOZWdhdGl2ZSBuLCBjbGFtcGVkIHRvIFsxLCAyNF0sIG1pbnVzIDEgKHRoZXJlJ3Mgbm8gbmVnYXRpdmUgMCkuXG4gICAgbiA9IE1hdGgubWluKE1hdGgubWF4KDAsIC1uKSwgMjQpIC0gMTtcbiAgICBjb25zdCBieXRlcyA9IFsoMSAvKiBTaWduZWRJbnRlZ2VyICovIDw8IDUpICsgbl07XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKS5idWZmZXI7XG59XG5leHBvcnRzLmlTbWFsbCA9IGlTbWFsbDtcbmZ1bmN0aW9uIGk4KGk4LCByYWRpeCkge1xuICAgIC8vIEZvcmNlIGk4IGludG8gYSBudW1iZXIsIGFuZCB2YWxpZGF0ZSBpdC5cbiAgICBpOCA9IHBhcnNlSW50KFwiXCIgKyBpOCwgcmFkaXgpO1xuICAgIGlmIChpc05hTihpOCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgfVxuICAgIC8vIE5lZ2F0aXZlIG4sIGNsYW1wZWQsIG1pbnVzIDEgKHRoZXJlJ3Mgbm8gbmVnYXRpdmUgMCkuXG4gICAgaTggPSBNYXRoLm1pbihNYXRoLm1heCgwLCAtaTggLSAxKSwgMHhmZik7XG4gICAgaTggPSBpOC50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIF9zZXJpYWxpemVWYWx1ZSgxIC8qIFNpZ25lZEludGVnZXIgKi8sIDI0IC8qIEludDggKi8sIGk4KTtcbn1cbmV4cG9ydHMuaTggPSBpODtcbmZ1bmN0aW9uIGkxNihpMTYsIHJhZGl4KSB7XG4gICAgLy8gRm9yY2UgaTE2IGludG8gYSBudW1iZXIsIGFuZCB2YWxpZGF0ZSBpdC5cbiAgICBpMTYgPSBwYXJzZUludChcIlwiICsgaTE2LCByYWRpeCk7XG4gICAgaWYgKGlzTmFOKGkxNikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgfVxuICAgIC8vIE5lZ2F0aXZlIG4sIGNsYW1wZWQsIG1pbnVzIDEgKHRoZXJlJ3Mgbm8gbmVnYXRpdmUgMCkuXG4gICAgaTE2ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgLWkxNiAtIDEpLCAweGZmZmYpO1xuICAgIGkxNiA9IGkxNi50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIF9zZXJpYWxpemVWYWx1ZSgxIC8qIFNpZ25lZEludGVnZXIgKi8sIDI1IC8qIEludDE2ICovLCBpMTYpO1xufVxuZXhwb3J0cy5pMTYgPSBpMTY7XG5mdW5jdGlvbiBpMzIoaTMyLCByYWRpeCkge1xuICAgIC8vIEZvcmNlIGkzMiBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgaTMyID0gcGFyc2VJbnQoXCJcIiArIGkzMiwgcmFkaXgpO1xuICAgIGlmIChpc05hTihpMzIpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICAvLyBOZWdhdGl2ZSBuLCBjbGFtcGVkLCBtaW51cyAxICh0aGVyZSdzIG5vIG5lZ2F0aXZlIDApLlxuICAgIGkzMiA9IE1hdGgubWluKE1hdGgubWF4KDAsIC1pMzIgLSAxKSwgMHhmZmZmZmZmZik7XG4gICAgaTMyID0gaTMyLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gX3NlcmlhbGl6ZVZhbHVlKDEgLyogU2lnbmVkSW50ZWdlciAqLywgMjYgLyogSW50MzIgKi8sIGkzMik7XG59XG5leHBvcnRzLmkzMiA9IGkzMjtcbmZ1bmN0aW9uIGk2NChpNjQsIHJhZGl4KSB7XG4gICAgLy8gU3BlY2lhbCBjb25zaWRlcmF0aW9uIGZvciBudW1iZXJzIHRoYXQgbWlnaHQgYmUgbGFyZ2VyIHRoYW4gZXhwZWN0ZWQuXG4gICAgaWYgKHR5cGVvZiBpNjQgPT0gXCJzdHJpbmdcIiAmJiByYWRpeCA9PSAxNikge1xuICAgICAgICBpZiAoaTY0LnN0YXJ0c1dpdGgoXCItXCIpKSB7XG4gICAgICAgICAgICBpNjQgPSBpNjQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDbGFtcCBpdC5cbiAgICAgICAgICAgIGk2NCA9IFwiMFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgY2FzZSB3aGVyZSB3ZSBndWFyYW50ZWUgd2UnbGwgZW5jb2RlIHRoZSBudW1iZXIgZGlyZWN0bHkuXG4gICAgICAgIC8vIFZhbGlkYXRlIGl0J3MgYWxsIGhleGFkZWNpbWFsIGZpcnN0LlxuICAgICAgICBpZiAoaTY0Lm1hdGNoKC9bXjAtOWEtZkEtRl0vKSB8fCBpNjQubGVuZ3RoID4gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZG8gLTEgdG8gdGhlIG51bWJlci5cbiAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgbGV0IG5ld0k2NCA9IGk2NC5zcGxpdChcIlwiKS5yZWR1Y2VSaWdodCgoYWNjLCB4KSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4ICsgYWNjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG4gPSBwYXJzZUludCh4LCAxNikgLSAxO1xuICAgICAgICAgICAgaWYgKG4gPj0gMCkge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBuLnRvU3RyaW5nKDE2KSArIGFjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImZcIiArIGFjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgXCJcIik7XG4gICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgLy8gVGhpcyBudW1iZXIgd2FzIDAuXG4gICAgICAgICAgICByZXR1cm4gdTY0KDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMSAvKiBTaWduZWRJbnRlZ2VyICovLCAyNyAvKiBJbnQ2NCAqLywgbmV3STY0KTtcbiAgICB9XG4gICAgLy8gRm9yY2UgaTY0IGludG8gYSBudW1iZXIsIGFuZCB2YWxpZGF0ZSBpdC5cbiAgICBpNjQgPSBwYXJzZUludChcIlwiICsgaTY0LCByYWRpeCk7XG4gICAgaWYgKGlzTmFOKGk2NCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgfVxuICAgIGk2NCA9IE1hdGgubWluKE1hdGgubWF4KDAsIC1pNjQgLSAxKSwgMHgyMDAwMDAwMDAwMDAwMCk7IC8vIENsYW1wIGl0IHRvIGFjdHVhbC5cbiAgICBpNjQgPSBpNjQudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMSAvKiBTaWduZWRJbnRlZ2VyICovLCAyNyAvKiBJbnQ2NCAqLywgaTY0KTtcbn1cbmV4cG9ydHMuaTY0ID0gaTY0O1xuLyoqXG4gKiBFbmNvZGUgYSBudW1iZXIgdXNpbmcgdGhlIHNtYWxsZXN0IGFtb3VudCBvZiBieXRlcywgYnkgY2FsbGluZyB0aGUgbWV0aG9kc1xuICogYWJvdmUuIGUuZy4gSWYgdGhlIG51bWJlciBmaXRzIGluIGEgdTgsIGl0IHdpbGwgdXNlIHRoYXQuXG4gKi9cbmZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKG4gPj0gMCkge1xuICAgICAgICBpZiAobiA8IDI0KSB7XG4gICAgICAgICAgICByZXR1cm4gdVNtYWxsKG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG4gPD0gMHhmZikge1xuICAgICAgICAgICAgcmV0dXJuIHU4KG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG4gPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gdTE2KG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG4gPD0gMHhmZmZmZmZmZikge1xuICAgICAgICAgICAgcmV0dXJuIHUzMihuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1NjQobik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChuID49IC0yNCkge1xuICAgICAgICAgICAgcmV0dXJuIGlTbWFsbChuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuID49IC0weGZmKSB7XG4gICAgICAgICAgICByZXR1cm4gaTgobik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobiA+PSAtMHhmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gaTE2KG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG4gPj0gLTB4ZmZmZmZmZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBpMzIobik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaTY0KG4pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG4vKipcbiAqIEVuY29kZSBhIGJ5dGUgYXJyYXkuIFRoaXMgaXMgZGlmZmVyZW50IHRoYW4gdGhlIGByYXcoKWAgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBieXRlcyhieXRlcykge1xuICAgIHJldHVybiBfY29uY2F0KF9zZXJpYWxpemVOdW1iZXIoMiAvKiBCeXRlU3RyaW5nICovLCBieXRlcy5ieXRlTGVuZ3RoKSwgYnl0ZXMpO1xufVxuZXhwb3J0cy5ieXRlcyA9IGJ5dGVzO1xuLyoqXG4gKiBFbmNvZGUgYSBKYXZhU2NyaXB0IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nKHN0cikge1xuICAgIHJldHVybiBfc2VyaWFsaXplU3RyaW5nKHN0cik7XG59XG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbi8qKlxuICogRW5jb2RlIGFuIGFycmF5IG9mIGNib3IgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBhcnJheShpdGVtcykge1xuICAgIHJldHVybiBfY29uY2F0KF9zZXJpYWxpemVOdW1iZXIoNCAvKiBBcnJheSAqLywgaXRlbXMubGVuZ3RoKSwgLi4uaXRlbXMpO1xufVxuZXhwb3J0cy5hcnJheSA9IGFycmF5O1xuLyoqXG4gKiBFbmNvZGUgYSBtYXAgb2Yga2V5LXZhbHVlIHBhaXJzLiBUaGUga2V5cyBhcmUgc3RyaW5nLCBhbmQgdGhlIHZhbHVlcyBhcmUgQ0JPUlxuICogZW5jb2RlZC5cbiAqL1xuZnVuY3Rpb24gbWFwKGl0ZW1zLCBzdGFibGUgPSBmYWxzZSkge1xuICAgIGlmICghKGl0ZW1zIGluc3RhbmNlb2YgTWFwKSkge1xuICAgICAgICBpdGVtcyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoaXRlbXMpKTtcbiAgICB9XG4gICAgbGV0IGVudHJpZXMgPSBBcnJheS5mcm9tKGl0ZW1zLmVudHJpZXMoKSk7XG4gICAgaWYgKHN0YWJsZSkge1xuICAgICAgICBlbnRyaWVzID0gZW50cmllcy5zb3J0KChba2V5QV0sIFtrZXlCXSkgPT4ga2V5QS5sb2NhbGVDb21wYXJlKGtleUIpKTtcbiAgICB9XG4gICAgcmV0dXJuIF9jb25jYXQoX3NlcmlhbGl6ZU51bWJlcig1IC8qIE1hcCAqLywgaXRlbXMuc2l6ZSksIC4uLmVudHJpZXMubWFwKChbaywgdl0pID0+IF9jb25jYXQoX3NlcmlhbGl6ZVN0cmluZyhrKSwgdikpKTtcbn1cbmV4cG9ydHMubWFwID0gbWFwO1xuLyoqXG4gKiBFbmNvZGUgYSBzaW5nbGUgKDMyIGJpdHMpIHByZWNpc2lvbiBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIHNpbmdsZUZsb2F0KGYpIHtcbiAgICBjb25zdCBzaW5nbGUgPSBuZXcgRmxvYXQzMkFycmF5KFtmXSk7XG4gICAgcmV0dXJuIF9jb25jYXQobmV3IFVpbnQ4QXJyYXkoWyg3IC8qIFNpbXBsZVZhbHVlICovIDw8IDUpICsgMjZdKSwgbmV3IFVpbnQ4QXJyYXkoc2luZ2xlLmJ1ZmZlcikpO1xufVxuZXhwb3J0cy5zaW5nbGVGbG9hdCA9IHNpbmdsZUZsb2F0O1xuLyoqXG4gKiBFbmNvZGUgYSBkb3VibGUgKDY0IGJpdHMpIHByZWNpc2lvbiBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGRvdWJsZUZsb2F0KGYpIHtcbiAgICBjb25zdCBzaW5nbGUgPSBuZXcgRmxvYXQ2NEFycmF5KFtmXSk7XG4gICAgcmV0dXJuIF9jb25jYXQobmV3IFVpbnQ4QXJyYXkoWyg3IC8qIFNpbXBsZVZhbHVlICovIDw8IDUpICsgMjddKSwgbmV3IFVpbnQ4QXJyYXkoc2luZ2xlLmJ1ZmZlcikpO1xufVxuZXhwb3J0cy5kb3VibGVGbG9hdCA9IGRvdWJsZUZsb2F0O1xuZnVuY3Rpb24gYm9vbCh2KSB7XG4gICAgcmV0dXJuIHYgPyB0cnVlXygpIDogZmFsc2VfKCk7XG59XG5leHBvcnRzLmJvb2wgPSBib29sO1xuLyoqXG4gKiBFbmNvZGUgdGhlIGJvb2xlYW4gdHJ1ZS5cbiAqL1xuZnVuY3Rpb24gdHJ1ZV8oKSB7XG4gICAgcmV0dXJuIHJhdyhuZXcgVWludDhBcnJheShbKDcgLyogU2ltcGxlVmFsdWUgKi8gPDwgNSkgKyAyMV0pKTtcbn1cbmV4cG9ydHMudHJ1ZV8gPSB0cnVlXztcbi8qKlxuICogRW5jb2RlIHRoZSBib29sZWFuIGZhbHNlLlxuICovXG5mdW5jdGlvbiBmYWxzZV8oKSB7XG4gICAgcmV0dXJuIHJhdyhuZXcgVWludDhBcnJheShbKDcgLyogU2ltcGxlVmFsdWUgKi8gPDwgNSkgKyAyMF0pKTtcbn1cbmV4cG9ydHMuZmFsc2VfID0gZmFsc2VfO1xuLyoqXG4gKiBFbmNvZGUgdGhlIGNvbnN0YW50IG51bGwuXG4gKi9cbmZ1bmN0aW9uIG51bGxfKCkge1xuICAgIHJldHVybiByYXcobmV3IFVpbnQ4QXJyYXkoWyg3IC8qIFNpbXBsZVZhbHVlICovIDw8IDUpICsgMjJdKSk7XG59XG5leHBvcnRzLm51bGxfID0gbnVsbF87XG4vKipcbiAqIEVuY29kZSB0aGUgY29uc3RhbnQgdW5kZWZpbmVkLlxuICovXG5mdW5jdGlvbiB1bmRlZmluZWRfKCkge1xuICAgIHJldHVybiByYXcobmV3IFVpbnQ4QXJyYXkoWyg3IC8qIFNpbXBsZVZhbHVlICovIDw8IDUpICsgMjNdKSk7XG59XG5leHBvcnRzLnVuZGVmaW5lZF8gPSB1bmRlZmluZWRfO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsdWUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/simple-cbor/src/value.js\n");

/***/ })

};
;