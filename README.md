# `playground`

To get started, you might want to explore the project directory structure and the default configuration file. Working with this project in your development environment will not affect any production deployment or identity tokens.

To learn more before you start working with `playground`, see the following documentation available online:

- [Quick Start](https://internetcomputer.org/docs/current/developer-docs/setup/deploy-locally)
- [SDK Developer Tools](https://internetcomputer.org/docs/current/developer-docs/setup/install)
- [Motoko Programming Language Guide](https://internetcomputer.org/docs/current/motoko/main/motoko)
- [Motoko Language Quick Reference](https://internetcomputer.org/docs/current/motoko/main/language-manual)

If you want to start working on your project right away, you might want to try the following commands:

Install dfx:

```
sh -ci "$(curl -fsSL https://internetcomputer.org/install.sh)"
dfx --version
```

```bash
cd src/playground_frontend/
dfx help
dfx canister --help
```

## Running the project locally

If you want to test your project locally, you can use the following commands:

```bash
# Starts the replica, running in the background
yarn chain

# Install necessary dependencies
yarn setup

# Build NextJS for deploying to frontend canister
yarn build

# Deploys your canisters to the local replica and generates your candid interface
yarn deploy
```

To start the frontend locally (not deploy as a canister), run:

```bash
yarn dev
```

Which will start a server at `http://localhost:3001`, proxying API requests to the replica at port 4943.

To deploy on vercel, make sure you first deploy the canister to mainnet or playground by running:

```
# Playground
yarn deploy --network playground

# Mainnet
yarn deploy --network ic
```

Then:
```
yarn vercel
```

### Note for NextJS

- After deploying your backend code as shown above, you can run Next.js local dev server npm run dev and edit your frontend code with all the benefits of hot code deploy.

- One thing to note is we use Next.js static code export here for hosting in Internet Computer so we can't use any features of Next.js that require server side NodeJS. Potentially, there might be ways to use Internet Computer canister as backend while deploying Next.js dapp to a hosting like Vercel that supports NodeJS server in the future. Further research is needed on that aspect. However, if you do want to run everything decentralized on blockchain including the frontend, you would want to deploy the exported static code to Internet Computer as well.



### Note on frontend environment variables

If you are hosting frontend code somewhere without using DFX, you may need to make one of the following adjustments to ensure your project does not fetch the root key in production:

- set`DFX_NETWORK` to `ic` if you are using Webpack
- use your own preferred method to replace `process.env.DFX_NETWORK` in the autogenerated declarations
  - Setting `canisters -> {asset_canister_id} -> declarations -> env_override to a string` in `dfx.json` will replace `process.env.DFX_NETWORK` with the string in the autogenerated declarations

### Type-Safe Contract Interaction with IC Reactor

This explains how to implement type-safe contract interactions in your Internet Computer (IC) dApp using the IC Reactor library.

#### Overview

The IC Reactor library provides a set of React hooks that enable type-safe interactions with IC canisters. It leverages TypeScript's type system to ensure compile-time type safety for all contract interactions.

#### Basic Setup

```typescript
import { createReactor } from "@ic-reactor/react"
import { idlFactory, your_backend } from "declarations/your_backend"

type Actor = typeof your_backend

export const { useActorStore, useAuth, useQueryCall, useUpdateCall } = createReactor<Actor>({
  canisterId: process.env.NEXT_PUBLIC_CANISTER_ID_YOUR_BACKEND || "",
  idlFactory,
  withLocalEnv: process.env.NEXT_PUBLIC_DFX_NETWORK === "local",
})
```

### Available Hooks

#### 1. useQueryCall
For querying canister methods:

```typescript
const { call, data, loading, error } = useQueryCall({
  functionName: 'getCount',
  args: [],
  refetchOnMount: true,
  refetchInterval: 5000, // Optional: Auto-refresh every 5 seconds
});
```

#### 2. useUpdateCall
For calling update methods:

```typescript
const { call, data, loading, error } = useUpdateCall({
  functionName: 'increment',
  args: [],
});
```

#### 3. useAuth
For authentication-related functionality:

```typescript
const { identity, isAuthenticated } = useAuth();
```

### Type Safety Features

1. **Method Name Validation**: The `functionName` parameter is type-checked against your canister's interface.
2. **Argument Type Checking**: Arguments passed to methods are validated against the Candid interface.
3. **Return Type Inference**: Return types are automatically inferred from the Candid interface.

### Example Usage

```typescript
import React from 'react';
import { useQueryCall, useUpdateCall } from './actor/actor';

const Counter: React.FC = () => {
  // Query call
  const { data: count } = useQueryCall({
    functionName: 'getCount',
    args: [],
    refetchOnMount: true,
  });

  // Update call
  const { call: increment } = useUpdateCall({
    functionName: 'increment',
    args: [],
  });

  return (
    <div>
      <h2>Count: {count !== undefined ? Number(count) : 'Loading...'}</h2>
      <button onClick={() => increment()}>Increment</button>
    </div>
  );
};
```

### Troubleshooting

1. **Type Errors**: If you encounter type errors, ensure your Candid interface is up to date by running:
```bash
dfx generate playground_backend
```

### Resources

- [IC Reactor Documentation](https://github.com/B3Pay/ic-reactor)
